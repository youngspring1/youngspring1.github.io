<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>行行重行行</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="不想当建筑师的程序员不是优秀的运动员">
<meta property="og:type" content="website">
<meta property="og:title" content="行行重行行">
<meta property="og:url" content="https://youngspring1.github.io/page/6/index.html">
<meta property="og:site_name" content="行行重行行">
<meta property="og:description" content="不想当建筑师的程序员不是优秀的运动员">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="行行重行行">
<meta name="twitter:description" content="不想当建筑师的程序员不是优秀的运动员">
  
    <link rel="alternate" href="/atom.xml" title="行行重行行" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">行行重行行</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://youngspring1.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2016-04-07-human-task-switches" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-04-07-human-task-switches/" class="article-date">
  <time datetime="2016-04-07T06:31:55.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-04-07-human-task-switches/">转：任务切换有害论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>书摘，来自《软件随想录》，Joel Spolsky </p>
</blockquote>
<p>在管理一个程序团队时，第一件要学的事就是任务配置(task allocation)要正确。「任务配置」只是把事情分给大家做的夸大说法。用希伯来文的普通话来说就是「倒文件」(因为你会把文件倒在某人身上)。有些事情做得对会得到不可思议的生产力利益，决定哪些文件要倒在谁身上就是其中之一。反过来没做好的话可能就会陷入麻烦的状况，没有人能做好何任何事情而且大家都抱怨「在这里什么事都做不起来。」</p>
<p>由于这是个针对程序员的网站，我要拿个程序设计问题让你的脑袋动一动暖暖身。</p>
<p>假设你有A和B两件运算要做。每一件都需10秒的CPU时间。现在你有一颗CPU，为了简化问题，所以工作序列中没有其他东西。</p>
<p>在我们的CPU中可以选择是否用多工处理。所以你可以先做好一件再做另一件。</p>
<h5 id="循序处理"><a href="#循序处理" class="headerlink" title="循序处理"></a>循序处理</h5><p>运算A<br>1    2    3    4    5    6    7    8    9    10<br>运算B<br>11    12    13    14    15    16    17    18    19    20   </p>
<p>也可以使用多工方式。如果用多工的话可以假设这颗特别的CPU每个工作每次可以执行一秒，而且工作切换完全不花时间。</p>
<h5 id="多工处理"><a href="#多工处理" class="headerlink" title="多工处理"></a>多工处理</h5><p>运算A<br>1    3    5    7    9    11    13    15    17    19<br>运算B<br>2    4    6    8    10    12    14    16    18    20   </p>
<p>你会选哪一种方式呢？大部份人的直觉反应都认为多工比较好。不管哪一种状况，都得等20秒才能两件运算都完成。不过可以想想单就各件运算来说要多久才有结果。</p>
<p>在两种状况下，运算B(标成蓝色)都要20秒才得到结果。不过运算A的结果在多工时需要19秒。可是循序时就只要10秒就好了。</p>
<p>换句话来说在这个安排好的例子中，循序处理的每件运算的平均时间比多工处理少(15秒对19.5秒)。(事实上这例子也并不是真的那么假 - 它是源于Jared在工作上必须解决的一个真实问题。)</p>
<p>方法    运算A花的时间    运算B花的时间    平均<br>循序处理    10秒    20秒    15<br>多工处理    19秒    20秒    19.5   </p>
<p>我刚刚说过「工作切换完全不花时间」。其实在真的CPU中工作切换是需要一点点时间的，基本上要足够储存CPU暂存器的状态并载入其他工作的CPU暂存器。实际上这短到几乎可以忽略。不过为了让生活更多乐趣，让我们假设工作切换需要半秒。现在情况变得更糟了：</p>
<p>方法    运算A花的时间    运算B花的时间    平均<br>循序处理    10秒    20秒 + 1次工作切换 = 20.5秒    15.25<br>多工处理    19秒 + 18次工作切换 = 28秒    20秒 + 19次工作切换 = 29.5秒    28.75   </p>
<p>现在呢，虽然我知道这有点蠢，不过就算为了让我高兴一下，想想如果工作切换需要一分钟拿如何？</p>
<p>方法    运算A花的时间    运算B花的时间    平均<br>循序处理    10秒    20秒 + 1次工作切换 = 80秒    45秒<br>多工处理    19秒 + 18次工作切换 = 1099秒    20秒 + 19次工作切换 = 1160秒    几近19分钟!!   </p>
<p>工作切换用的时间愈长，多工处理的代价愈大。</p>
<p>这件事本身不怎么新奇，不是吗？不久大概就会有些白痴气愤地写信指控我「反对」多工处理了。他们会质问我：「你真的想要回到那种得先结束WordPerfect才能执行Lotus 1-2-3的DOS时代吗？」</p>
<p>不过那并不是我的意思。我只是想要你同意，在这类例子中：</p>
<ul>
<li>循序处理会让结果平均上比较快得到，而且</li>
<li>工作切换需要愈久，多工处理所付的代价就愈大。</li>
</ul>
<p>够了，别管CPU了，来管管人吧，这有趣多了。这里的重点在于管理「程序员」时，工作切换会需要很长很长的时间。因为程序设计这种工作必须同时在脑袋里记很多东西。另外记住的东西愈多，写程序时生产力愈高。用全速写程序的程序员脑里随时都会记住无数的事情：变量名称，数据结构，重要的API，写过常要用到的辅助函数名称，甚至存放源代码的次目录名称，一切东西都要记住。如果你把程序员送到克利特岛去度假三星期，他所有东西通通都会忘掉。人脑似乎会把东西移出短期RAM，改存到永远都读不回来的备份磁带上。</p>
<p>要多久呢？嗯，我的软件公司最近放下手头上在做的事(开发一套代号CityDesk的软件产品)，花了三星期去帮助某个客户处理一个紧急状况。当我们回到办公室时，感觉好像要另外三星期才能回复全速制作CityDesk。</p>
<p>就个人层次来说，你曾经注意过某件事吗？叫某人做一个工作可以做得很好，可是如果给他两个工作，他会把其中一个做好却忽略另一个，不然就是两件工作都做得很慢，慢到你觉得懒鬼都比他勤劳。这是因为程序设计的工作就是需要很长的切换时间。就我自己来说，当我需要同时完成两个程序设计项目时，切换时间大概要六个小时。以一天八小时来看，等于说多工处理把我的生产力降到每天只剩二小时。真令人沮丧啊。</p>
<p>同样的道理，如果你给某人两件工作，应该要感谢他们只做一件工作而放弃另一件，因为这样能做好更多的事，而且平均上也能更快完成工作。事实上这一切的重点就是绝对不要让人同时做一件以上的事。请确定你有明白它的意思。好的经理人会认为自己的责任是消除障碍，好让大家都能专注在一件事情并把它真的完成。遇到紧急状况时，请先想想能不能自己处理掉，真的不行再丢给深陷在项目中的程序员吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-04-07-human-task-switches/" data-id="cjqj71z6y003hl3w8td6b8zcy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/joel-on-software/">joel on software</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-04-02-datatable4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-04-02-datatable4/" class="article-date">
  <time datetime="2016-04-01T15:38:11.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/data-table教程/">data.table教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-04-02-datatable4/">data.table 教程4－二级索引和自动索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目录：   </p>
<ol>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-13-datatable1/">data.table 介绍</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-21-datatable2/">语义引用</a>      </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-22-datatable3/">主键、基于二分法搜索的subset</a>    </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-02-datatable4/">二次索引和自动索引</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-08-datatable5/">数据拆分和合并</a>   </li>
</ol>
<p>原文地址：<br><a href="https://github.com/Rdatatable/data.table/wiki/Getting-started" target="_blank" rel="external">data.table/wiki/Getting-started</a></p>
<hr>
<p>感谢<a href="http://weibo.com/u/2120911240" target="_blank" rel="external">G_天星</a>的提醒，貌似现在版本的data.table中还没有setindex()函数，所以可能应该使用set2key()函数。或者通过代码安装data.table试试。</p>
<hr>
<h1 id="二级索引和自动索引"><a href="#二级索引和自动索引" class="headerlink" title="二级索引和自动索引"></a>二级索引和自动索引</h1><p>本教程假定读者已经熟悉data.table的[i, j, by]语法、懂得如何基于二分法的选取了。如果你对这些不熟悉，请学习上面三讲 <a href="http://youngspring1.github.io/post/2016-03-13-datatable1/">data.table 介绍</a> 、 <a href="http://youngspring1.github.io/post/2016-03-21-datatable2/">语义引用</a>和<a href="http://youngspring1.github.io/post/2016-03-22-datatable3/">主键、基于快速二分法搜索的subset</a>。 </p>
<hr>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>我们继续使用已经保存到本地的航班信息flights。</p>
<pre><code>flights &lt;- fread(&quot;flights14.csv&quot;)
head(flights)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
# 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18
dim(flights)
# [1] 253316     11
</code></pre><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这一讲，我们会：   </p>
<ul>
<li>讨论二级索引。  </li>
<li>再次演示快速subset，但这次我们使用新的参数on，它能自动设置二级索引。</li>
<li>最后进一步的，来看一下自动索引，它也能自动设置索引，但是它是基于R的原生语法来做subset的。</li>
</ul>
<h2 id="1-二级索引"><a href="#1-二级索引" class="headerlink" title="1.二级索引"></a>1.二级索引</h2><h4 id="a-什么是二级索引"><a href="#a-什么是二级索引" class="headerlink" title="a) 什么是二级索引"></a>a) 什么是二级索引</h4><p>二级索引和data.table的主键类似，但有以下两点不同：</p>
<ul>
<li>它不会再内存里将整个data.table重新排序。它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。</li>
<li>一个data.table可以有多个二级索引，这是我们下面要演示的。</li>
</ul>
<h4 id="b-设置和获取二级索引"><a href="#b-设置和获取二级索引" class="headerlink" title="b) 设置和获取二级索引"></a>b) 设置和获取二级索引</h4><p>－如何将origin列设置为该data.table的二级索引</p>
<pre><code>setindex(flights, origin)
head(flights)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
# 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18

## alternatively we can provide character vectors to the function &apos;setindexv()&apos;
# setindexv(flights, &quot;origin&quot;) # useful to program with

# &apos;index&apos; attribute added
names(attributes(flights))
# [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;
# [5] &quot;index&quot;
</code></pre><p>说明：   </p>
<ul>
<li>函数setindex 和 setindexv()可以对data.table添加一个二级索引。</li>
<li>注意flights实际上没有按照origin列的升序重新排列。还记得吗？setkey()会重新排序！</li>
<li>setindex(flights, NULL)会删除所有的二级索引。</li>
</ul>
<p>－如何取得flights的二级索引</p>
<pre><code>indices(flights)
# [1] &quot;origin&quot;

setindex(flights, origin, dest)
indices(flights)
# [1] &quot;origin&quot;       &quot;origin__dest&quot;
</code></pre><p>说明：   </p>
<ul>
<li>函数indices()返回一个data.table所有的二级索引。如果该data.table没有二级索引，那么返回NULL。</li>
<li>注意我们对 origin列,dest列创建了另一个二级索引的时候，我们没有丢掉之前创建的第一个二级索引。也就是说，我们可以创建多个二级索引。</li>
</ul>
<h4 id="c-为什么使用二级索引"><a href="#c-为什么使用二级索引" class="headerlink" title="c) 为什么使用二级索引"></a>c) 为什么使用二级索引</h4><p>－对一个data.table重新排序成本太高<br>考虑一下这种情况，当你想用主键origin列来subset所有“JFK”的时候，我们得这么做：</p>
<pre><code>## not run
setkey(flights, origin)
flights[&quot;JFK&quot;] # or flights[.(&quot;JFK&quot;)]
</code></pre><p>说明：</p>
<pre><code>setkey()需要：
a.计算得出origin列的排序向量，并且
b.基于刚刚的排序向量，对整个data.table重新排序
</code></pre><p>排序并不是最花时间的，因为data.table使用对整型、字符型、数值型的向量进行radix排序。然而重新排序却很花时间。<br>除非我们需要对某一列重复地进行subset，否则二分法快速subset的高效可能被重新排序抵消。   </p>
<p>－为添加／更新列而对整个data.table重新排序并不理想<br>－最多只能有一个主键<br>现在我们如果想对dest列是“LAX”的行，重复地进行某个特定的操作，那么我们必须再调用函数setkey() 设置一次主键。   </p>
<pre><code>## not run
setkey(flights, dest)
flights[&quot;LAX&quot;]
</code></pre><p>这样，flights又再次按dest列重新排序了。其实我们真正想做的是，快速地subset同时又不必重新排序。<br>这时候，二级索引就派上用场了！   </p>
<p>－二级索引可以被重用<br>既然一个data.table中可以有多个二级索引，并且创建一个二级索引就和将一个排序向量保存为属性一样简单，那么创建二级索引后，我们可以省下重新排序的时间。<br>－参数on使得语法更简洁，并且能自动创建并重用二级索引<br>我们下面一节会说明参数on的几个优点：   </p>
<p>参数on</p>
<ul>
<li>通过创建索引进行subset。每次都能节省setindex()的时间。</li>
<li>通过检查属性，可以简单地重用已经存在的二级索引。</li>
<li>语法简单。<br>注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。</li>
</ul>
<h2 id="2-使用参数on和索引进行快速subset"><a href="#2-使用参数on和索引进行快速subset" class="headerlink" title="2.使用参数on和索引进行快速subset"></a>2.使用参数on和索引进行快速subset</h2><h4 id="a-参数i里的subset"><a href="#a-参数i里的subset" class="headerlink" title="a) 参数i里的subset"></a>a) 参数i里的subset</h4><p>－subset所有origin是“JFK”的行</p>
<pre><code>flights[&quot;JFK&quot;, on = &quot;origin&quot;]
#        year month day dep_delay arr_delay carrier origin dest air_time distance hour
#     1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
#     2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
#     3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
#     4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
#     5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
#    ---
# 81479: 2014    10  31        -4       -21      UA    JFK  SFO      337     2586   17
# 81480: 2014    10  31        -2       -37      UA    JFK  SFO      344     2586   18
# 81481: 2014    10  31         0       -33      UA    JFK  LAX      320     2475   17
# 81482: 2014    10  31        -6       -38      UA    JFK  SFO      343     2586    9
# 81483: 2014    10  31        -6       -38      UA    JFK  LAX      323     2475   11

## alternatively
# flights[.(&quot;JFK&quot;), on = &quot;origin&quot;] (or) 
# flights[list(&quot;JFK&quot;), on = &quot;origin&quot;]
</code></pre><p>说明：</p>
<ul>
<li>这段语句执行的subset也是通过创建二级索引，基于快速二分法搜索的。但记住，它不会把这个二级索引自动创建为data.table的一个属性。当然后面我们也会教你如何将它设置为一个属性。   </li>
<li>如果我们已经添加了一个二级索引了，那么参数on就可以直接使用这个二级索引，而不是再对整个航班信息flights进行计算。   </li>
</ul>
<p>我们来看下面 verbose = TRUE 的用法：</p>
<pre><code>setindex(flights, origin)
flights[&quot;JFK&quot;, on = &quot;origin&quot;, verbose = TRUE][1:5]
# names(on) = NULL. Assigning &apos;on&apos; to names(on)&apos; as well.
# Looking for existing (secondary) index... found. Reusing index.
# Starting bmerge ...done in 0 secs
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
</code></pre><p>－如何对origin列和dest列进行subset<br>举个例子，如果我们想选取所有从“JFK”起飞到达“LAX”的所有航班：</p>
<pre><code>flights[.(&quot;JFK&quot;, &quot;LAX&quot;), on = c(&quot;origin&quot;, &quot;dest&quot;)][1:5]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
</code></pre><p>说明：</p>
<ul>
<li>在参数i里面指定取值，在参数on里面指定列名。参数on必须是一个字符型的向量。   </li>
<li>因为计算索引非常快，所以我们不需要使用setindex()。除非你需要对某一列重复地进行subset操作。   </li>
</ul>
<h4 id="b-参数j里的select"><a href="#b-参数j里的select" class="headerlink" title="b) 参数j里的select"></a>b) 参数j里的select</h4><p>下面我们将要讨论的所有操作，跟我们在上一讲里面学习的类似。只是我们现在使用参数on。<br>－返回满足条件 origin = “LGA” and dest = “TPA”的 arr_delay列的值</p>
<pre><code>flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)]
#       arr_delay
#    1:         1
#    2:        14
#    3:       -17
#    4:        -4
#    5:       -12
#   ---          
# 1848:        39
# 1849:       -24
# 1850:       -12
# 1851:        21
# 1852:       -11
</code></pre><h4 id="c-Chaining"><a href="#c-Chaining" class="headerlink" title="c) Chaining"></a>c) Chaining</h4><p>－在上面的基础上，使用chaining来将结果降序排列</p>
<pre><code>flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)][order(-arr_delay)]
#       arr_delay
#    1:       486
#    2:       380
#    3:       351
#    4:       318
#    5:       300
#   ---          
# 1848:       -40
# 1849:       -43
# 1850:       -46
# 1851:       -48
# 1852:       -49
</code></pre><h4 id="d-参数j里的计算"><a href="#d-参数j里的计算" class="headerlink" title="d) 参数j里的计算"></a>d) 参数j里的计算</h4><p>－找出满足条件 origin = “LGA” and dest = “TPA”的 arr_delay列的最大值（航班到达的最长延误时间）</p>
<pre><code>flights[.(&quot;LGA&quot;, &quot;TPA&quot;), max(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)]
# [1] 486
</code></pre><h4 id="e-参数j里使用操作符”-”进行sub-assign"><a href="#e-参数j里使用操作符”-”进行sub-assign" class="headerlink" title="e) 参数j里使用操作符”:=”进行sub-assign"></a>e) 参数j里使用操作符”:=”进行sub-assign</h4><p>在上一讲中，我们学习过了类似的功能。同样地，现在我们看看如何找到在flights里面，hours列所有可能的取值：   </p>
<pre><code># get all &apos;hours&apos; in flights
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
</code></pre><p>可以看到，一共有25种不同的取值。但是0点和24点其实是同样的。下面我们把24全部替换成0，但是这次我们使用参数on。   </p>
<pre><code>flights[.(24L), hour := 0L, on = &quot;hour&quot;]
</code></pre><p>现在我们再来看看24是不是都被替换成0了：   </p>
<pre><code>flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
</code></pre><p>说明：</p>
<ul>
<li>这真是二级索引的一大优点。以前，只是为了更新一些行的hour列的取值，我们不得不调用函数setkey()将hour列设置为主键，这必须对整个data.table进行重新排序。但是现在，用参数on，原数据的顺序并没有改变，操作反而更快了！而代码还是如此简洁。   </li>
</ul>
<h4 id="f-通过参数by聚合"><a href="#f-通过参数by聚合" class="headerlink" title="f) 通过参数by聚合"></a>f) 通过参数by聚合</h4><p>－找到每月从“JFK”起飞的航班起飞的最长延误时间，并按照月份排序</p>
<pre><code>ans &lt;- flights[&quot;JFK&quot;, max(dep_delay), keyby = month, on = &quot;origin&quot;]
head(ans)
#    month   V1
# 1:     1  881
# 2:     2 1014
# 3:     3  920
# 4:     4 1241
# 5:     5  853
# 6:     6  798
</code></pre><p>说明：</p>
<ul>
<li>如果我们不使用二级索引，也就是不在参数on里面指定，那么我们就必须把origin设置为主键。   </li>
</ul>
<h4 id="g-参数mult"><a href="#g-参数mult" class="headerlink" title="g) 参数mult"></a>g) 参数mult</h4><p>参数mult和上一讲一样。它的默认值是“all”。我们可以选择是第一条还是最后一条符合条件的行被返回。<br>－subset满足条件dest ＝ “BOS” 和 “DAY”的第一行   </p>
<pre><code>flights[c(&quot;BOS&quot;, &quot;DAY&quot;), on = &quot;dest&quot;, mult = &quot;first&quot;]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1         3         1      AA    JFK  BOS       39      187   12
# 2: 2014     1   1        25        35      EV    EWR  DAY      102      533   17
</code></pre><p>－subset满足条件 origin ＝ “LGA” 或者 “JFK” 或者 “EWR”，并且 dest ＝ “XNA” 的最后一行   </p>
<pre><code>flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), on = c(&quot;origin&quot;, &quot;dest&quot;), mult = &quot;last&quot;]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6
# 2:   NA    NA  NA        NA        NA      NA    JFK  XNA       NA       NA   NA
# 3: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6
</code></pre><h4 id="h-参数nomatch"><a href="#h-参数nomatch" class="headerlink" title="h) 参数nomatch"></a>h) 参数nomatch</h4><p>如果查询语句没有找到任何匹配的数据，通过指定参数nomatch，我们可以选择是返回 NA，还是忽略。<br>－在上面这个列子中，忽略没有实际意义的数据   </p>
<pre><code>flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), mult = &quot;last&quot;, on = c(&quot;origin&quot;, &quot;dest&quot;), nomatch = 0L]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6
# 2: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6
</code></pre><p>说明：</p>
<ul>
<li>没有航班从“JFK”起飞到达“XNA”，所以结果里面，这一行被忽略了。   </li>
</ul>
<h2 id="3-自动索引"><a href="#3-自动索引" class="headerlink" title="3.自动索引"></a>3.自动索引</h2><p>回顾一下，我们先学习如何通过主键使用快速二分法搜索进行subset。接着，我们学习了使用二级索引，它带来更好的效果，而且语法也更简洁。<br>等等，有没有更好的方法？有！优化R的原生语法，使用内置的索引。这样我们毋需使用新的语法，就能得到同样的效果。<br>这就是自动索引。<br>目前，它只支持操作符 == 和 %in% 。而且只对一列起作用。某一列会被自动创建为索引，并且作为data.table的属性保存起来。这跟参数on不同，参数on会每次创建一个临时索引，所以才会被叫做“二级索引”。   </p>
<p>让我们创建一个极大的data.table来凸显它的优势。  </p>
<pre><code>set.seed(1L)
dt = data.table(x = sample(1e5L, 1e7L, TRUE), y = runif(100L))
print(object.size(dt), units = &quot;Mb&quot;)
# 114.4 Mb
</code></pre><p>当我们第一次对某一列使用 == 或者 %in% 的时候，会自动创建一个二级索引，它会被用来进行subset。</p>
<pre><code># have a look at all the attribute names
names(attributes(dt))
# [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;

## run thefirst time
(t1 &lt;- system.time(ans &lt;- dt[x == 989L]))
#    user  system elapsed 
#   0.235   0.013   0.249
head(ans)
#      x         y
# 1: 989 0.5372007
# 2: 989 0.5642786
# 3: 989 0.7151100
# 4: 989 0.3920405
# 5: 989 0.9547465
# 6: 989 0.2914710

## secondary index is created
names(attributes(dt))
# [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;
# [5] &quot;index&quot;

indices(dt)
# [1] &quot;x&quot;
</code></pre><p>第一次subset的时候，就是创建索引的时候。因为创建二级索引只会引入一个排序向量，在很多情况下，这种操作符的方式会比扫描向量快得多。所以，从第二次subset开始，自动索引的优势就非常明显了：</p>
<pre><code>## successive subsets
(t2 &lt;- system.time(dt[x == 989L]))
#    user  system elapsed 
#   0.001   0.000   0.001
system.time(dt[x %in% 1989:2012])
#    user  system elapsed 
#   0.001   0.000   0.001
</code></pre><p>说明：</p>
<ul>
<li>第一次subset花了0.228秒，但是第二次只花了0.001秒！   </li>
<li>可以通过设置全局参数关闭自动索引：options(datatable.auto.index = FALSE)。   </li>
</ul>
<p>我们正在将二分法搜索扩展到其它的操作符，比如 &lt;, &lt;= 和 &gt;=。完成之后，就能直接用在其他操作符上了。<br>在将来，我们计划将自动索引扩展到参数中的其它列。   </p>
<p>在下一讲“结合和滚动结合”中，我们会学习使用主键和二级索引进行快速subset。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-04-02-datatable4/" data-id="cjqj71z75003nl3w8uazwbfub" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/R/">R</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-table/">data.table</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-30-write-fd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-03-30-write-fd/" class="article-date">
  <time datetime="2016-03-30T05:19:46.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-03-30-write-fd/">为什么程序员要写功能设计书</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>续上篇，还是阅读了《软件随想录》之后，希望把以前的思考再总结一下。   </p>
<hr>
<h2 id="1-什么是功能设计书"><a href="#1-什么是功能设计书" class="headerlink" title="1.什么是功能设计书"></a>1.什么是功能设计书</h2><pre><code>功能设计书
  从用户的角度，完整描述了程序的行为。它只介绍了程序的功能、交互方式，并不涉及具体的实现方式。   

技术设计书
  指引程序员，如何实现功能设计书所描述的功能。它涉及数据结构、数据库、程序语言、算法等等内部的实现细节。   
</code></pre><p>从头开始设计一个程序时，最重要的，是完成对用户交互的设计：用户需要哪些功能；这些功能具体需要哪些页面来实现；页面如何操作。<br>功能设计书的写作者需要将整个软件的所有可能的使用场景、流程，在自己的脑海中想象出来，并展现在功能设计书当中。   </p>
<h2 id="2-为什么要写功能设计书"><a href="#2-为什么要写功能设计书" class="headerlink" title="2.为什么要写功能设计书"></a>2.为什么要写功能设计书</h2><p>有好多同事觉得写设计书没有必要，浪费开发的时间，而且对个人能力没有提升。<br>我无法想象他们是如何得到这些结论的。可能我在学生时代也是这么想的，看到一个任务就马上写代码，但我早就不这样做了。</p>
<h4 id="2-1-设计"><a href="#2-1-设计" class="headerlink" title="2.1 设计"></a>2.1 设计</h4><p>功能设计书最重要作用，就是对程序所有的功能进行设计。通过写文档描述所有页面交互的细节，你会被迫对程序做真正的设计。<br>在程序的使用中，有可能遇到什么问题，应该如何处理，你在设计阶段就应该想清楚。在写作中，那些可能出问题的地方，大部分都能暴露出来；而如果不写设计书，当你写了一些代码之后，才发现这些问题，付出的代价会更大。<br>所以设计能够大幅度缩短整个项目的开发周期。   </p>
<p>更重要的，这对你个人的思维能力和表达能力都很有提升。<br>看上去，设计的成果是一篇文档，但为了写作这篇文档，你在脑海中进行的一系列思维活动，才是你最大的收获。</p>
<h4 id="2-2-沟通"><a href="#2-2-沟通" class="headerlink" title="2.2 沟通"></a>2.2 沟通</h4><p>有没有回忆起，用户／开发人员／测试人员一次次的跟你确认功能设计的情景？他们东一句西一句地跑过来问你各种愚蠢的问题，你的工作时间被消磨殆尽。<br>通过功能设计书，你只需要跟别人沟通一次；其他人员只要去阅读功能设计书，就能知道你能给他们的所有信息。<br>如果没有功能设计书，你只能一遍一遍地讲给他们听。<br>更可怕的是，如果没有功能设计书，测试人员会根据程序的输入输出来测试程序，或者根据开发人员的实现细节来测试程序，而不是基于设计来设计程序。   </p>
<h4 id="2-3-计划"><a href="#2-3-计划" class="headerlink" title="2.3 计划"></a>2.3 计划</h4><p>如果没有功能设计书把所有的功能点／页面罗列出来，如何安排计划呢。</p>
<h2 id="2-谁来读功能设计书"><a href="#2-谁来读功能设计书" class="headerlink" title="2.谁来读功能设计书"></a>2.谁来读功能设计书</h2><pre><code>客户
  这里的客户，是那些付钱给你开发程序的人。
  友情提醒你一下，要把他们想象成一毛不拔的铁公鸡，妄图只花5块钱买一架航空母舰。
  写作功能设计书的时候，需要一遍又一遍的跟他们确认，跟他们的想象和需求是否一致。这里的功能设计书，就是必须的“立字据”。基本完成之后，再修改是要加钱的哦。
用户
  这里的用户，是那些使用程序的人。
  友情提醒你一下，要把他们想象成又笨又懒的人，他们什么都不会，什么都不想做。
  但你的功能设计书，必须要把他们教会使用这个程序。
技术设计书的作者
  技术设计书的作者，需要根据功能设计书，考虑如何实现程序。
开发人员
  开发人员，主要按照技术设计书来实现程序，但是也会参考功能设计书，确认功能是否都实现了，页面流程是否一致。
测试人员
  测试人员，需要按照功能设计书来写测试案例，并最终实施测试任务。
</code></pre><h2 id="3-谁来写功能设计书"><a href="#3-谁来写功能设计书" class="headerlink" title="3.谁来写功能设计书"></a>3.谁来写功能设计书</h2><p>不同的公司，会有不同的职位和称呼，而且写作功能设计书的人，又不是专职写作功能设计书的。<br>所以这里，我并不会将什么人来写，而是简单说下，写作功能设计书的人，需要哪些素质。</p>
<h4 id="3-1-技术能力"><a href="#3-1-技术能力" class="headerlink" title="3.1 技术能力"></a>3.1 技术能力</h4><p>虽然功能设计书本身并不涉及具体的实现方式，但是，作者必须明白，功能点都是在成本范围内能够实现。这就要求作者必须要有技术功底。<br>这也是为什么，本文的标题是“为什么程序员要写功能设计书”，有过开发背景的人，才会具备技术功底。其他人员，很可惜，我觉得不具备写作功能设计书的能力。   </p>
<h4 id="3-2-思维能力"><a href="#3-2-思维能力" class="headerlink" title="3.2 思维能力"></a>3.2 思维能力</h4><p>将脑海中的设计，通过确切的图片和简要的语言，展现在文档中。我认为这不是写作能力，而是思维能力。</p>
<h4 id="3-3-沟通能力"><a href="#3-3-沟通能力" class="headerlink" title="3.3 沟通能力"></a>3.3 沟通能力</h4><p>功能设计书不是独自写完就可以的。而是要跟其他所有读者沟通达成一致后，才能最终定稿。   </p>
<h2 id="4-如何写功能设计书"><a href="#4-如何写功能设计书" class="headerlink" title="4.如何写功能设计书"></a>4.如何写功能设计书</h2><h4 id="4-1-应当包含哪些要素"><a href="#4-1-应当包含哪些要素" class="headerlink" title="4.1 应当包含哪些要素"></a>4.1 应当包含哪些要素</h4><pre><code>概述
  该程序的主要功能。
使用场景
  在什么情况下，可以使用该程序。
流程图
  程序各个页面的关系，也是整个服务的全貌。
每个页面的功能说明
  所有页面的详细功能。
细节！细节！细节！
  重要的事情说三遍。页面上所有可能出现的细节都要考虑到，所有可能影响页面的因素都要考虑到。在这些情况下，程序如何反应，写下来。
待解决的问题
  文档不可能在第一版就达到完善的状态，这是你要把还不清楚的地方写下来。
多角度的注解
  主要是从开发人员或者测试人员的角度，需要注意的细节。
修改履历
  所有的读者，都会根据修改履历，大概了解每次修改的功能点和位置。
</code></pre><h4 id="4-2-写作原则"><a href="#4-2-写作原则" class="headerlink" title="4.2 写作原则"></a>4.2 写作原则</h4><pre><code>简单
  能用图片的，尽量用图片而不是语言。能少说的，就不多说。
用户角度
  从用户的角度思考问题，想想用户需要知道什么信息。
评审
  自己阅读，甚至大声朗读几遍。拿给所有必需的读者看。再修改。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-03-30-write-fd/" data-id="cjqj71z70003kl3w8spfk9rc5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/software/">software</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-27-joe-on-soft" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-03-27-joe-on-soft/" class="article-date">
  <time datetime="2016-03-27T05:53:14.000Z" itemprop="datePublished">2016-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-03-27-joe-on-soft/">软件随想录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这周看了一本很有意思的书，《软件随想录》，其实有两卷，是StackOverflow的创始人和CEO发表的blog文集。<br>不管是程序员，还是跟程序员打交道的人，都可以读一读，一定会很有收获。   </p>
<p>我就不抄书了，谈谈我自己在工作中的一些感想吧。   </p>
<h4 id="1-面试题"><a href="#1-面试题" class="headerlink" title="1.面试题"></a>1.面试题</h4><p>给小朋友面试的时候，公司会给一些题库，里面有好多经典的面试题，我严重怀疑面试的学生已经背得滚瓜烂熟了，反正基本上都能很快的答上来。但是要是出个笔试题，让他们手写几行（我以为）简单的代码，一天下来十几个人竟然没有一个能完全做对的。<br>我常常想，这些面试题有什么用？工作中基本不会用到，实在有一些细节的知识点，用的时候再查资料就可以了。<br>听上去没什么不对的，也许这就是马路上好多IT培训广告的原因，也许这就是公司招近好多不合格的“野生程序员”的原因。<br>今天看了书才知道，上学时候学习的那些基础课，不是让我们在日后的工作中使用的，而是提前做一次筛选，提醒那些不适合做程序员的人知难而退；然后磨炼留下的人，将他们提高到一个高度，这样以后再做工作上的事，就游刃有余了。   </p>
<p>补充一个学习理念：<br>当你小学三年级的时候，会觉得题目很难；但是当你高中的时候，会觉得小学的题目都很简单。那么，先将自己提升到高中的水平，和那些小学生一起，做小学生的题目。嗯，你一定能够碾压你的竞争对手。   </p>
<h4 id="2-成长"><a href="#2-成长" class="headerlink" title="2.成长"></a>2.成长</h4><p>刚刚进公司的时候，有“总结－分享－成长”这样的氛围。比如，做项目到一定的阶段，大家会各自总结在这过程中，做得好的不好的地方，分析原因、提出对策，然后在下一次类似的机会中实践；一个人学习了新的知识点，一定会形成文档，下次别人遇到了问题，直接去问他或者看文档，有时还会组织分享会来讲解；如此这般，很容易感受到自身的成长。<br>而现在，大家都分散着做各自的项目，几乎没有时间和渠道交流。离职率也很高，各自学习自己感兴趣的东西。这也导致完全无心来培养一个新手，反正培养出来了也是要走的。哼哼。</p>
<h4 id="3-是geek还是农民工"><a href="#3-是geek还是农民工" class="headerlink" title="3.是geek还是农民工"></a>3.是geek还是农民工</h4><p>和程序员以外的人交流，噢，简直没法交流啊。就连本来应该懂一点技术的产品经理，也是拿各种不相关的词汇生搬硬套，并且妄图做技术上的决策。业务部的人，简直把程序员当成实现他们需求的工具，而且常常会想用1块钱的成本做10块钱的事，还觉得只值5毛钱。哼哼。<br>所以理想的情况，还是待在geek文化比较强烈的公司吧。</p>
<hr>
<p>亚马逊链接：<br><a href="http://www.amazon.cn/图书/dp/B00WDTQU8M?ie=UTF8&amp;psc=1&amp;ref_=oh_aui_detailpage_o00_s00" target="_blank" rel="external">软件随想录 I</a><br><a href="http://www.amazon.cn/图书/dp/B00WFT32FY?ie=UTF8&amp;psc=1&amp;ref_=oh_aui_detailpage_o00_s00" target="_blank" rel="external">软件随想录 II</a>   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-03-27-joe-on-soft/" data-id="cjqj71z6u003dl3w8atomr3ef" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/software/">software</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-26-work-simpler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-03-26-work-simpler/" class="article-date">
  <time datetime="2016-03-25T16:44:24.000Z" itemprop="datePublished">2016-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生活/">生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-03-26-work-simpler/">转：如何不做多任务工作 — 更简单理智地去工作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转帖评论：   </p>
<p>没有所谓的多任务处理。<br>CPU也是一个个任务分时间段单独执行，或者在独立的核心上面分布处理的呢。<br>人类在多任务处理方面更加无能，就好比无法一边写代码，一边做饭。特别的，两个不同的任务之间切换的时候，人类需要更多的切换时间，想想你刚刚玩了一局精彩的游戏，至少要回味10分钟😄，才能投入到工作吧。   </p>
<p>因此减少任务的切换，是一个解决方案。<br>也就是说，留出大段不受打扰的时间。<br>写代码是一种需要精力高度集中的工作，有时看上去我的手指都没有动，一行代码都没有写，事实上，我在脑海中搭建巴别塔呢，这时候，如果来一个人问我一个问题，那么，不管我的巴别塔盖了100层还是50层，一会儿我都要重新从地面开始搭建555。所以如果你作为一个程序员，工作的时候常常不受打扰，珍惜这份工作吧。<br>这也是为什么，我工作的时候常常戴着耳塞，因为这样就把全世界关掉了呀。</p>
<hr>
<pre><code>出处：微信公众号“聪明人的个人发展”，译者“晓飞”
</code></pre><hr>
<p>你同时忙着两个项目，而老板又在桌上放了两个新工作需求。你正打着电话，此时又来了三封电邮。你正试图按时下班，以便在回家路上为晚餐买些食材。你的黑莓手机没电了，而另一个手机也是如此。你的同事过来索要某份信息数据，而你的博客订阅器里还有100多条未读信息。</p>
<p>你如同马戏团里的杂耍人一样，处理着多项任务。祝贺你如此能干，多任务处理者。</p>
<p>在这个即时科技时代，我们都被过量信息和占用个人时间的各种需求所轰炸。这也是GTD管理系统为何在信息世界如此流行的部分原因 — 这个系统的设计目的就是为了做出快速决定，并让个人的所有生活需求保持秩序井然。但即便在使用GTD管理系统，我们有时仍会被各种事情弄得不堪重负，自己的管理系统也开始分崩离析。</p>
<p>Life Hack网站最近发布了一篇《如何处理多任务》的文章，它是篇针对多任务工作的本质，以及如何在多任务工作的同时，仍能一次专注于一项任务的好文章。</p>
<p>但我这篇文章是《如何不做多任务工作》— 指导你为了身心健康，怎样尽可能简单地去工作。</p>
<p>首先，以下是不做多任务工作的简短理由：</p>
<ol>
<li><p>由于人们需要为处理每项新任务转换工作状态，然后又要切换回先前任务的工作状态，多任务工作并不高效。</p>
</li>
<li><p>多任务工作更加复杂，因此更容易制造压力和犯错。</p>
</li>
<li><p>多任务工作繁忙疯狂，而且在这个已经显得混乱的世界里，我们需要掌控内心恐惧，找寻一点理智和沉静心态的绿洲。</p>
</li>
</ol>
<p>下面就是如何不做多任务工作的一些建议：</p>
<ol>
<li><p>首先，请根据你的实际情形，为不同的工作内容（即电话、电脑、杂事、家事、等候事项等）设定待做事项列表。</p>
</li>
<li><p>为即时记录需要完成的事项，准备一种记录工具（比如一本笔记本）。</p>
</li>
<li><p>准备一个实物收件箱和电邮收件箱（收件箱数量要尽可能少），以使你收到的所有东西都能汇集到一个地方（实物收件箱用于收纳纸张物品，电邮收件箱用于存放数字信息）。</p>
</li>
<li><p>以时间块的方式计划当天生活，并在中间为紧急事项预留空白时段。取决于哪种做法对自己最适用，你可以尝试一小时长度的时间块，或半小时长度的时间块。或试试这种：40分钟长度的时间块，中间留出20分钟处理各种杂事。</p>
</li>
<li><p>早晨第一件事，就是处理个人最重要任务（蓝色字体可点击）。在最重要任务完成前，别干其他任何事情。做完首个任务后休息一会儿，再开始完成下一个最重要任务。如果你能在上午做完2-3个最重要任务，当天剩余时间便无比轻松自在。</p>
</li>
<li><p>在一个时间块内处理某项任务时，请关闭其他所有分心事物。关掉邮箱，如果可以就断掉互联网。关闭手机。假如可能就努力别接电话。专注于那项任务，在不去担心其他任何事情的情况下，努力将它完成。</p>
</li>
<li><p>若你感到有查看电邮或转换到其他任务上的冲动，请阻止自己。做做深呼吸。重新专注于自我。回到你手头的那项任务。</p>
</li>
<li><p>如果在工作时收到其他东西，请把它们放进收件箱，或在记录系统里做好笔记。随后回归你的手头任务。</p>
</li>
<li><p>当完成手头任务后，请不时处理一下你的笔记和收件箱，将新任务添加到待做事项列表，并在需要时重新制定日程安排。按照定期和预先设定的时间间隔处理个人邮件和其他收件箱。</p>
</li>
<li><p>有时干扰事项会非常紧急，以致于你无法将它推迟到完成手头任务后再做处理。在此情形下，请努力记下当前的工作进度（若有时间请写下进度笔记），把跟那项任务相关的所有文件或笔记内容放在一起（也许可以放进“行动”文件夹或项目文件夹）。然后，当你回归那项任务时，便可拿出对应文件夹，查看先前笔记来确定自己暂停工作的地方。</p>
</li>
<li><p>请做做深呼吸，伸伸四肢，时不时休息一下。好好享受生活。出门走走，欣赏自然美景。让自己保持理智状态。</p>
</li>
</ol>
<p>Leo Babauta（里奥·巴伯塔）<br>2007.02.19</p>
<hr>
<p>感谢Leo公开放弃自己博客内容（zenhabits.net）的版权<br><a href="http://zenhabits.net/how-not-to-multitask-work-simpler-and/#rd?sukey=a76cdd086edb4fce38bde6191fdb1ccc2a5900824eda91c2970e203265a37440c95c66d0f3c39f4c65e24b9867312dc3" target="_blank" rel="external">阅读原文</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-03-26-work-simpler/" data-id="cjqj71z6n0036l3w8ojo4kzci" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/简单工作/">简单工作</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-26-shinyserver-jp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-03-26-shinyserver-jp/" class="article-date">
  <time datetime="2016-03-25T16:08:31.000Z" itemprop="datePublished">2016-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/新知/">新知</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-03-26-shinyserver-jp/">Shiny Server インストール手順</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Rは、統計に対して、とても便利ですが、ユーザに向けインタフェースはそんなに良くないと思います。<br>Shiny Serverは、Webサービスのように、ユーザの入力から、Rで計算して、ブラウザで結果を表示するサーバです。<br>インストール手順は、下記の通りです。<br>環境は、イントネットに接続できないCentOS 6.5 x64です。   </p>
<h4 id="1-ソースからRのインストール"><a href="#1-ソースからRのインストール" class="headerlink" title="1.ソースからRのインストール"></a>1.ソースからRのインストール</h4><pre><code>./configure --prefix=/opt/r --enable-R-shlib 
make 
make install 
</code></pre><p>注意1：PATHは、ファイル「/etc/profile」で設定してください。<br>注意2：Rは、他のコンポに依頼します。下記のコマンドは、実行することが必要かもしれません。エラーメッセージにより確認してください。</p>
<pre><code>yum install gcc-gfortran 
yum install readline-devel 
yum install libXt-devel 
yum install gcc-c++ glibc-headers
</code></pre><h4 id="2-Xvfbのインストール"><a href="#2-Xvfbのインストール" class="headerlink" title="2.Xvfbのインストール"></a>2.Xvfbのインストール</h4><pre><code>yum install Xvfb
</code></pre><p>説明：絵の作るのは、デフォルトが X11ですが、いろいろな問題があります。最後、Xvfbになりました。   </p>
<h4 id="3-Shinyのインストール"><a href="#3-Shinyのインストール" class="headerlink" title="3.Shinyのインストール"></a>3.Shinyのインストール</h4><h5 id="3-1-Shiny-libのインストール"><a href="#3-1-Shiny-libのインストール" class="headerlink" title="3.1 Shiny libのインストール"></a>3.1 Shiny libのインストール</h5><p>Rのコンソールで、Shiny libをインストールします。   </p>
<pre><code>install.packages(&apos;shiny&apos;)
</code></pre><p>他のlibに依頼しますが、もしサーバは、いんとねっとに接続できないなら、インストールファイルをダウンロードして、サーバに置いて、ファイルからインストールします。<br>Rのコンソールから、quit()して、下記のようなコマンドを実行します。</p>
<pre><code>R CMD INSTALL XXXXX.tar.gz 
</code></pre><h5 id="3-2-Shiny-Serverのインストール"><a href="#3-2-Shiny-Serverのインストール" class="headerlink" title="3.2 Shiny Serverのインストール"></a>3.2 Shiny Serverのインストール</h5><pre><code>yum install --nogpgcheck shiny-server-1.4.2.786-rh5-x86_64.rpm 
</code></pre><p>設定ファイルは、下記のパスです：</p>
<pre><code>/etc/shiny-server/shiny-server.conf 
</code></pre><p>確認のために、Shiny libの10個の例を、shiny-serverのサーバディレクトリにコピーします。   </p>
<pre><code>cp -R /opt/r/lib64/R/library/shiny/examples/* /srv/shiny-server/
</code></pre><p>上記により、すべてのAPPは、ディレクトリ「/srv/shiny-server/」に置きます。そして、ブラウザでアクセスできます。</p>
<pre><code>http://localhost:3838/目录名
</code></pre><p>それ以外、起動・停止コマンド：</p>
<pre><code>start shiny-server 
stop shiny-server 
restart shiny-server 
status shiny-server 
reload shiny-server #サービスを中止しないように、更新内容をロード
</code></pre><p>ホーンページを確認しますか：   </p>
<pre><code>http://localhost:3838/index.html
</code></pre><p>画面を表示できますが、絵は誤りがありそうです。</p>
<h4 id="4-絵の作り"><a href="#4-絵の作り" class="headerlink" title="4.絵の作り"></a>4.絵の作り</h4><h5 id="4-1-Xvfbの起動"><a href="#4-1-Xvfbの起動" class="headerlink" title="4.1 Xvfbの起動"></a>4.1 Xvfbの起動</h5><p>X11を使ったら、エラー「can’t start PNG device」になります。<br>そのために、X11の代わりに，Xvfbを使います。<br>Xvfbを起動します。</p>
<pre><code>Xvfb :3 -screen 1 1280x1024x24
</code></pre><h5 id="4-1-設定"><a href="#4-1-設定" class="headerlink" title="4.1 設定"></a>4.1 設定</h5><p>ui.Rには、下記の内容を追加します。</p>
<pre><code>Sys.setenv(DISPLAY = &quot;:3.1&quot;)
</code></pre><p>例を確認しませんか。</p>
<pre><code>http://localhost:3838/index.html 
http://localhost:3838/01_hello/ 
http://localhost:3838/02_text/
http://localhost:3838/03_reactivity/
http://localhost:3838/04_mpg/
http://localhost:3838/05_sliders/
http://localhost:3838/06_tabsets/
http://localhost:3838/07_widgets/
http://localhost:3838/08_html/
http://localhost:3838/09_upload/
http://localhost:3838/10_download/
http://localhost:3838/11_timer/
</code></pre><hr>
<p>参照：<a href="https://www.rstudio.com/products/shiny/shiny-server2/" target="_blank" rel="external">https://www.rstudio.com/products/shiny/shiny-server2/</a><br>中国語版：<a href="http://youngspring1.github.io/post/2016-03-25-shinyserver/">http://youngspring1.github.io/post/2016-03-25-shinyserver/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-03-26-shinyserver-jp/" data-id="cjqj71z6l0035l3w8guq76hsi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/R/">R</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shiny-server/">shiny server</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-25-shinyserver" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-03-25-shinyserver/" class="article-date">
  <time datetime="2016-03-25T04:00:38.000Z" itemprop="datePublished">2016-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/新知/">新知</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-03-25-shinyserver/">Shiny Server 安装步骤</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>R语言非常适合用于统计相关的运算。但是在用户交互方面不够友好。<br>Shiny Server是RStudio推出的，一个Web服务。它可以接受用户的输入，使用R语言进行计算，最终展示计算结果。这一切都在浏览器上完成。<br>总之非常实用，现在整理下我自己的安装手册。</p>
<h4 id="1-从代码安装R"><a href="#1-从代码安装R" class="headerlink" title="1.从代码安装R"></a>1.从代码安装R</h4><pre><code>./configure --prefix=/opt/r --enable-R-shlib 
make 
make install 
</code></pre><p>注意1：PATH要设置这个文件，否则可能会找不到R ：/etc/profile<br>注意2：可能依赖其他包比如fortran，你可能还需要执行下面这些命令。   </p>
<pre><code>yum install gcc-gfortran 
yum install readline-devel 
yum install libXt-devel 
yum install gcc-c++ glibc-headers
</code></pre><h4 id="2-安装Xvfb"><a href="#2-安装Xvfb" class="headerlink" title="2.安装Xvfb"></a>2.安装Xvfb</h4><pre><code>yum install Xvfb
</code></pre><p>说明：绘制图形好像默认使用 X11，但是安装过程中遇到了各种麻烦，最后尝试了这个，能够正常显示。   </p>
<h4 id="3-安装Shiny"><a href="#3-安装Shiny" class="headerlink" title="3.安装Shiny"></a>3.安装Shiny</h4><h5 id="3-1-安装Shiny"><a href="#3-1-安装Shiny" class="headerlink" title="3.1 安装Shiny"></a>3.1 安装Shiny</h5><p>R命令行下面安装Shiny的包。</p>
<pre><code>install.packages(&apos;shiny&apos;)
</code></pre><p>安装过程中，会安装其他依赖的包。<br>如果你跟我一样，服务器不能连网络，那就必须下载好压缩包，再传到服务器上，从本地安装。<br>但是不在R命令行下，而是还要quit()退出来。<br>安装的命令长这样：</p>
<pre><code>R CMD INSTALL XXXXX.tar.gz 
</code></pre><h5 id="3-2-安装Shiny-Server"><a href="#3-2-安装Shiny-Server" class="headerlink" title="3.2 安装Shiny Server"></a>3.2 安装Shiny Server</h5><pre><code>yum install --nogpgcheck shiny-server-1.4.2.786-rh5-x86_64.rpm 
</code></pre><p>配置文件路径：</p>
<pre><code>/etc/shiny-server/shiny-server.conf 
</code></pre><p>你可以把shiny包里面自带的10个例子，都拷贝到shiny-server的目录下去。   </p>
<pre><code>cp -R /opt/r/lib64/R/library/shiny/examples/* /srv/shiny-server/
</code></pre><p>是的，你以后所有的APP都要在/srv/shiny-server/目录下，然后在浏览器中通过这样的方式来访问：</p>
<pre><code>http://localhost:3838/目录名
</code></pre><p>另外，启动／停止等命令：</p>
<pre><code>start shiny-server 
stop shiny-server 
restart shiny-server 
status shiny-server 
reload shiny-server #不中断服务的前提下 更新加载配置项
</code></pre><p>这时可以看下首页：   </p>
<pre><code>http://localhost:3838/index.html
</code></pre><p>页面能够显示，但是绘图的部分好像报错了。</p>
<h4 id="4-绘图引擎"><a href="#4-绘图引擎" class="headerlink" title="4.绘图引擎"></a>4.绘图引擎</h4><h5 id="4-1-启动Xvfb"><a href="#4-1-启动Xvfb" class="headerlink" title="4.1 启动Xvfb"></a>4.1 启动Xvfb</h5><p>各种泪流满面啊，九牛二虎啊。之前安装一堆东西，企图使用X11，会报错：can’t start PNG device。<br>后来放弃X11，使用Xvfb。需要启动Xvfb。</p>
<pre><code>Xvfb :3 -screen 1 1280x1024x24
</code></pre><h5 id="4-1-设置"><a href="#4-1-设置" class="headerlink" title="4.1 设置"></a>4.1 设置</h5><p>ui.R需要加入下面这一行：</p>
<pre><code>Sys.setenv(DISPLAY = &quot;:3.1&quot;)
</code></pre><p>访问示例试试：</p>
<pre><code>http://localhost:3838/index.html 
http://localhost:3838/01_hello/ 
http://localhost:3838/02_text/
http://localhost:3838/03_reactivity/
http://localhost:3838/04_mpg/
http://localhost:3838/05_sliders/
http://localhost:3838/06_tabsets/
http://localhost:3838/07_widgets/
http://localhost:3838/08_html/
http://localhost:3838/09_upload/
http://localhost:3838/10_download/
http://localhost:3838/11_timer/
</code></pre><hr>
<p>参照：<a href="https://www.rstudio.com/products/shiny/shiny-server2/" target="_blank" rel="external">https://www.rstudio.com/products/shiny/shiny-server2/</a><br>日文版：<a href="http://youngspring1.github.io/post/2016-03-26-shinyserver-jp/">http://youngspring1.github.io/post/2016-03-26-shinyserver-jp/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-03-25-shinyserver/" data-id="cjqj71z6r003al3w8hr02x8h4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/R/">R</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shiny-server/">shiny server</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-22-datatable3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-03-22-datatable3/" class="article-date">
  <time datetime="2016-03-22T07:58:42.000Z" itemprop="datePublished">2016-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/data-table教程/">data.table教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-03-22-datatable3/">data.table 教程3－主键、基于二分法搜索的subset</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目录：   </p>
<ol>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-13-datatable1/">data.table 介绍</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-21-datatable2/">语义引用</a>      </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-22-datatable3/">主键、基于二分法搜索的subset</a>    </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-02-datatable4/">二次索引和自动索引</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-08-datatable5/">数据拆分和合并</a>   </li>
</ol>
<p>原文地址：<br><a href="https://github.com/Rdatatable/data.table/wiki/Getting-started" target="_blank" rel="external">data.table/wiki/Getting-started</a></p>
<hr>
<p>本教程主要提供给那些已经熟悉data.table的语法、懂得subset行select列、知道如何添加／更新／删除列的人员学习。如果你对这些不熟悉，请学习上面两讲 <a href="http://youngspring1.github.io/post/2016-03-13-datatable1/">data.table 介绍</a> 和 <a href="http://youngspring1.github.io/post/2016-03-21-datatable2/">语义引用</a>。 </p>
<hr>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>我们继续使用上一讲中使用的航班信息flights。</p>
<pre><code>flights &lt;- fread(&quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/    flights/NYCflights14/flights14.csv&quot;)
flights
#         year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
#      1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
#      2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
#      3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
#      4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
#      5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
#     ---                                                                                      
# 253312: 2014    10  31     1459         1     1747       -30         0      UA  N23708   1744
# 253313: 2014    10  31      854        -5     1147       -14         0      UA  N33132   1758
# 253314: 2014    10  31     1102        -8     1311        16         0      MQ  N827MQ   3591
# 253315: 2014    10  31     1106        -4     1325        15         0      MQ  N511MQ   3592
# 253316: 2014    10  31      824        -5     1045         1         0      MQ  N813MQ   3599
#         origin dest air_time distance hour min
#      1:    JFK  LAX      359     2475    9  14
#      2:    JFK  LAX      363     2475   11  57
#      3:    JFK  LAX      351     2475   19   2
#      4:    LGA  PBI      157     1035    7  22
#      5:    JFK  LAX      350     2475   13  47
#     ---                                       
# 253312:    LGA  IAH      201     1416   14  59
# 253313:    EWR  IAH      189     1400    8  54
# 253314:    LGA  RDU       83      431   11   2
# 253315:    LGA  DTW       75      502   11   6
# 253316:    LGA  SDF      110      659    8  24
dim(flights)
# [1] 253316     17
</code></pre><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这一讲，我们会：   </p>
<pre><code>* 介绍“主键”的概念，在参数i里面，设置并使用主键进行基于快速二分法搜索的subset。
* 学习如何将基于主键的subset，与参数i和by相结合，就像以前做的一样。
* 学习另外两个有用的参数 mult 和 nomatch
* 最后总结一下主键的优越性：基于快速二分法搜索的subset的表现，并和传统的vector scan approach对比。
</code></pre><h2 id="1-主键"><a href="#1-主键" class="headerlink" title="1.主键"></a>1.主键</h2><h4 id="a-什么是主键"><a href="#a-什么是主键" class="headerlink" title="a) 什么是主键"></a>a) 什么是主键</h4><p>在<a href="http://youngspring1.github.io/post/2016-03-13-datatable1/">data.table 介绍</a>里，我们学习了如何在参数i里指定逻辑表达式和行号subset行，以及如何使用 order().在这一讲，我们会学习如何使用主键subset行，而且这难以置信的快。<br>但首先，我们从data.frame开始。所有的data.frame都有一个行名的属性。看下面这个data.frame DF。</p>
<pre><code>set.seed(1L)
DF = data.frame(ID1 = sample(letters[1:2], 10, TRUE), 
                ID2 = sample(1:3, 10, TRUE),
                val = sample(10), 
                stringsAsFactors = FALSE,
                row.names = sample(LETTERS[1:10]))
DF
#   ID1 ID2 val
# C   a   3   5
# D   a   1   6
# E   b   2   4
# G   a   1   2
# B   b   1  10
# H   a   2   8
# I   b   1   9
# F   b   2   1
# J   a   3   7
# A   b   2   3

rownames(DF)
#  [1] &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;G&quot; &quot;B&quot; &quot;H&quot; &quot;I&quot; &quot;F&quot; &quot;J&quot; &quot;A&quot;
</code></pre><p>我们可以用行名来subset一行，就像这样：</p>
<pre><code>DF[&quot;C&quot;, ]
#   ID1 ID2 val
# C   a   3   5
</code></pre><p>行名，或多或少，算是一个data.frame的索引。然而，   </p>
<ol>
<li>每行都有且只有一个行名。<br>但是，一个人可能有两个名字，比如名字和中间名。当编纂电话簿的时候，这就非常有用。</li>
<li><p>而且行名必须是独一无二的。</p>
<p> rownames(DF) = sample(LETTERS[1:5], 10, TRUE)</p>
<h1 id="Warning-non-unique-values-when-setting-‘row-names’-‘C’-‘D’"><a href="#Warning-non-unique-values-when-setting-‘row-names’-‘C’-‘D’" class="headerlink" title="Warning: non-unique values when setting ‘row.names’: ‘C’, ‘D’"></a>Warning: non-unique values when setting ‘row.names’: ‘C’, ‘D’</h1><h1 id="Error-in-row-names-lt-data-frame-tmp-value-value-duplicate-‘row-names’-are-not-allowed"><a href="#Error-in-row-names-lt-data-frame-tmp-value-value-duplicate-‘row-names’-are-not-allowed" class="headerlink" title="Error in row.names&lt;-.data.frame(*tmp*, value = value): duplicate ‘row.names’ are not allowed"></a>Error in <code>row.names&lt;-.data.frame</code>(<code>*tmp*</code>, value = value): duplicate ‘row.names’ are not allowed</h1></li>
</ol>
<p>下面我们来看看data.table吧。</p>
<pre><code>DT = as.data.table(DF)
DT
#     ID1 ID2 val
#  1:   a   3   5
#  2:   a   1   6
#  3:   b   2   4
#  4:   a   1   2
#  5:   b   1  10
#  6:   a   2   8
#  7:   b   1   9
#  8:   b   2   1
#  9:   a   3   7
# 10:   b   2   3

rownames(DT)
#  [1] &quot;1&quot;  &quot;2&quot;  &quot;3&quot;  &quot;4&quot;  &quot;5&quot;  &quot;6&quot;  &quot;7&quot;  &quot;8&quot;  &quot;9&quot;  &quot;10&quot;
</code></pre><p>注意：</p>
<pre><code>* 行名被重置了。
* data.table从来不使用行名。既然data.table集成了data.frame，那它还是有行名这个属性的，但是从来不使用。马上我们就知道为什么了。
如果想保持行名，在调用 as.data.table()的时候指定 keep.rownames = TRUE，这回创建一个叫做 rn的列，并且将列名赋值给这一列。
</code></pre><p>而在data.table里，我们使用主键。主键是更有效的行名。</p>
<pre><code>主键及其特性
* 我们可以对多个列设置主键，这些列可能是不同的类型－integer, numeric, character, factor, integer64等等。但还不支持list和complex。
* 不强制唯一性，也就是说，不同列的主键可以是一样的。既然行可以通过主键排序，那么排序的时候，具有同样主键的一些行，会被排在一起。
* 设置主键这个过程分两步：
  a.根据指定的列，对data.table重新排序，而且总是按升序排列。
  b.对于data.table，通过设置一个叫做 sorted 的属性，来把那些列标记为主键列。
  既然是排序，一个data.table最多只能有一个主键，因为它不能按照两种方法排序。
</code></pre><p>在教程接下来的部分，我们一直都是用航班信息 flights 来讲解。</p>
<h3 id="b-设置／获取／使用主键"><a href="#b-设置／获取／使用主键" class="headerlink" title="b) 设置／获取／使用主键"></a>b) 设置／获取／使用主键</h3><p>－如何将 origin列设置为主键</p>
<pre><code>setkey(flights, origin)
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
# 2: 2014     1   1     1655        -5     2003       -17         0      AA  N5CFAA    172    EWR
# 3: 2014     1   1     1611       191     1910       185         0      AA  N471AA    300    EWR
# 4: 2014     1   1     1449        -1     1753        -2         0      AA  N4WNAA    320    EWR
# 5: 2014     1   1      607        -3      905       -10         0      AA  N5DMAA   1205    EWR
# 6: 2014     1   1      949         4     1243       -17         0      AA  N491AA   1223    EWR
#    dest air_time distance hour min
# 1:  LAX      339     2454   18  24
# 2:  MIA      161     1085   16  55
# 3:  DFW      214     1372   16  11
# 4:  DFW      214     1372   14  49
# 5:  MIA      154     1085    6   7
# 6:  DFW      215     1372    9  49

## alternatively we can provide character vectors to the function &apos;setkeyv()&apos;
# setkeyv(flights, &quot;origin&quot;) # useful to program with
</code></pre><p>说明：</p>
<pre><code>* 你可以给函数setkey() 传入列名作为参数，不需要引号。这在交互式使用的时候特别方便。
* 换一种方式，你可以给函数setkeyv() 传一个字符型的向量，这个向量里保存的是列名。这在把列作为参数传给一个新创建的函数，来设置主键的时候特别方便。
* 注意，我们不需要将结果赋值给一个变量。这是因为，setkey() 和 setkeyv()可以直接更新输入的data.table，就和上一讲中的操作符&quot;:=&quot;一样。它们没有返回值。
* 现在这个data.table已经按照我们提供的 origin列重新排序了。虽然是重新排序，但我们只需要请求和data.table的行数等长的一列这么大的内存空间。你看，又节省内存开销了。
* 你也可以在创建data.table的时候，调用函数data.table() 的参数 key=，直接设置主键，参数key的值是列名的字符型向量。
</code></pre><p>注意：</p>
<pre><code>set* and :=:
在data.table里，操作符&quot;:=&quot;和所有的以set开头函数（比如setkey,setorder,setname等）一样，它们都会更新输入的原数据。
</code></pre><p>一旦将某一列设置成data.table的主键，就可以在参数i里指定 .()来subset那些主键了。回忆一下，.()就是 list()的别名。</p>
<p>－使用主键origin 来subset所有origin是”JFK”的行</p>
<pre><code>flights[.(&quot;JFK&quot;)]
#        year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
#     1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
#     2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
#     3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
#     4: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
#     5: 2014     1   1     2133        -2       37       -18         0      AA  N323AA    185    JFK
#    ---                                                                                             
# 81479: 2014    10  31     1705        -4     2024       -21         0      UA  N596UA    512    JFK
# 81480: 2014    10  31     1827        -2     2133       -37         0      UA  N568UA    514    JFK
# 81481: 2014    10  31     1753         0     2039       -33         0      UA  N518UA    535    JFK
# 81482: 2014    10  31      924        -6     1228       -38         0      UA  N512UA    541    JFK
# 81483: 2014    10  31     1124        -6     1408       -38         0      UA  N590UA    703    JFK
#        dest air_time distance hour min
#     1:  LAX      359     2475    9  14
#     2:  LAX      363     2475   11  57
#     3:  LAX      351     2475   19   2
#     4:  LAX      350     2475   13  47
#     5:  LAX      338     2475   21  33
#    ---                                
# 81479:  SFO      337     2586   17   5
# 81480:  SFO      344     2586   18  27
# 81481:  LAX      320     2475   17  53
# 81482:  SFO      343     2586    9  24
# 81483:  LAX      323     2475   11  24

## alternatively
# flights[J(&quot;JFK&quot;)] (or) flights[list(&quot;JFK&quot;)]
</code></pre><p>说明：</p>
<pre><code>* 因为已经将主键设置为 origin列了，所以只要直接指定&quot;JFK&quot;就可以了。这里 .()用来在data.table的主键（也就是flights 的 origin列）里，查找&quot;JFK&quot;。
* 首先，满足&quot;JFK&quot;条件的行的索引都被获取到。然后，这些行的哪些信息是必要的呢。既然参数j里没有指定任何表达式，这些行的所有列都被返回了。
* 如果主键是字符型的列，那么可以省略 .()，就像用行名subset一个data.frame的行的时候。
flights[&quot;JFK&quot;]              ## same as flights[.(&quot;JFK&quot;)]

* 我们可以根据需要指定多个值
flights[c(&quot;JFK&quot;, &quot;LGA&quot;)]    ## same as flights[.(c(&quot;JFK&quot;, &quot;LGA&quot;))]
这返回所有 origin列是“JFK” 或者 “LGA”的所有行。
</code></pre><p>－如何获得被设置为data.table的主键的那一列的列名<br>使用函数 key()。</p>
<pre><code>key(flights)
# [1] &quot;origin&quot;
</code></pre><p>说明：</p>
<pre><code>* 函数 key() 返回主键列名的字符型向量。
* 如果data.table没有设置过主键，返回 NULL。
</code></pre><h4 id="c-主键和多个列"><a href="#c-主键和多个列" class="headerlink" title="c) 主键和多个列"></a>c) 主键和多个列</h4><p>主键是更有效的行名。我们可以将多个列设置为主键，它们可以是不同的类型。<br>－如何将 origin列 和 dest列 都设置为主键</p>
<pre><code>setkey(flights, origin, dest)
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   2      724        -2      810       -25         0      EV  N11547   4373    EWR
# 2: 2014     1   3     2313        88        9        79         0      EV  N18120   4470    EWR
# 3: 2014     1   4     1526       220     1618       211         0      EV  N11184   4373    EWR
# 4: 2014     1   4      755        35      848        19         0      EV  N14905   4551    EWR
# 5: 2014     1   5      817        47      921        42         0      EV  N19966   4470    EWR
# 6: 2014     1   5     2301        66        2        62         0      EV  N19966   4682    EWR
#    dest air_time distance hour min
# 1:  ALB       30      143    7  24
# 2:  ALB       29      143   23  13
# 3:  ALB       32      143   15  26
# 4:  ALB       32      143    7  55
# 5:  ALB       26      143    8  17
# 6:  ALB       31      143   23   1

## or alternatively
# setkeyv(flights, c(&quot;origin&quot;, &quot;dest&quot;)) # provide a character vector of column names

key(flights)
# [1] &quot;origin&quot; &quot;dest&quot;
</code></pre><p>说明：</p>
<pre><code>* data.table先按 origin列 排序，再按 dest列 排序。
</code></pre><p>－subset所有满足条件 origin是”JFK”、dest是”MIA”的行</p>
<pre><code>flights[.(&quot;JFK&quot;, &quot;MIA&quot;)]
#       year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
#    1: 2014     1   1     1509        -1     1828       -17         0      AA  N5FJAA    145    JFK
#    2: 2014     1   1      917         7     1227        -8         0      AA  N5DWAA   1085    JFK
#    3: 2014     1   1     1227         2     1534        -1         0      AA  N635AA   1697    JFK
#    4: 2014     1   1      546         6      853         3         0      AA  N5CGAA   2243    JFK
#    5: 2014     1   1     1736         6     2043       -12         0      AA  N397AA   2351    JFK
#   ---                                                                                             
# 2746: 2014    10  31     1659        -1     1956       -22         0      AA  N5FNAA   2351    JFK
# 2747: 2014    10  31      826        -3     1116       -20         0      AA  N5EYAA   1085    JFK
# 2748: 2014    10  31      647         2      941       -17         0      AA  N5BTAA   1101    JFK
# 2749: 2014    10  31      542        -3      834       -12         0      AA  N3ETAA   2299    JFK
# 2750: 2014    10  31     1944        29     2232         4         0      AA  N5FSAA   2387    JFK
#       dest air_time distance hour min
#    1:  MIA      161     1089   15   9
#     2:  MIA      166     1089    9  17
#    3:  MIA      164     1089   12  27
#    4:  MIA      157     1089    5  46
#    5:  MIA      154     1089   17  36
#   ---                                
# 2746:  MIA      148     1089   16  59
# 2747:  MIA      146     1089    8  26
# 2748:  MIA      150     1089    6  47
# 2749:  MIA      150     1089    5  42
# 2750:  MIA      146     1089   19  44
</code></pre><p>说明：</p>
<pre><code>这里发生了什么事？
* 理解内部的处理步骤很重要。首先，用&quot;JFK&quot;和第一个主键 origin列匹配；然后，在匹配上的这些行里，用“MIA”和第二个主键 dest列匹配，这样来获取所有符合这两个条件的行的索引。
* 既然我们没有指定参数j，那就会返回所有符合上面索引的行。
</code></pre><p>－subset所有仅仅满足条件dest是”MIA”的行</p>
<pre><code>flights[.(unique(origin), &quot;MIA&quot;)]
#       year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
#    1: 2014     1   1     1655        -5     2003       -17         0      AA  N5CFAA    172    EWR
#    2: 2014     1   1      607        -3      905       -10         0      AA  N5DMAA   1205    EWR
#    3: 2014     1   1     1125        -5     1427        -8         0      AA  N3AGAA   1623    EWR
#    4: 2014     1   1     1533        43     1840        42         0      UA  N491UA    244    EWR
#    5: 2014     1   1     2130        60       29        49         0      UA  N476UA    308    EWR
#   ---                                                                                             
# 9924: 2014    10  31     1348       -11     1658        -8         0      AA  N3AMAA   2283    LGA
# 9925: 2014    10  31      950        -5     1257       -11         0      AA  N3LFAA   2287    LGA
# 9926: 2014    10  31      658        -2     1017        10         0      AA  N3HNAA   2451    LGA
# 9927: 2014    10  31     1913        -2     2212       -16         0      AA  N3LFAA   2455    LGA
# 9928: 2014    10  31     1530         1     1839       -11         0      US  N768US   1715    LGA
#       dest air_time distance hour min
#    1:  MIA      161     1085   16  55
#    2:  MIA      154     1085    6   7
#    3:  MIA      157     1085   11  25
#    4:  MIA      155     1085   15  33
#    5:  MIA      162     1085   21  30
#   ---                                
# 9924:  MIA      157     1096   13  48
# 9925:  MIA      150     1096    9  50
# 9926:  MIA      156     1096    6  58
# 9927:  MIA      156     1096   19  13
# 9928:  MIA      164     1096   15  30
</code></pre><p>说明：</p>
<pre><code>这里发生了什么事？
* 回忆一下刚刚讲的处理步骤。首先，找到满足第一个主键origin列的条件的行；然后在这个结果中，找到满足第二个主键dest列是“MIA”的行。我们不能简单地事先跳过第一个主键列。因此，我们必须通过主键 origin列，获得它所有可能的取值。
* “MIA”会被自动补足成跟 unique(origin) 同样的长度，也就是3。
</code></pre><h2 id="2-和参数j、参数by一起使用"><a href="#2-和参数j、参数by一起使用" class="headerlink" title="2. 和参数j、参数by一起使用"></a>2. 和参数j、参数by一起使用</h2><p>到目前为止，我们学习的都是同样的概念，也就是通过参数i取得行，只是使用了主键这种新的方法。那么同样的，我们在参数j和参数by里面使用主键，也没什么大惊小怪的。我们通过几个例子来说明。</p>
<h4 id="a-在参数j里面select"><a href="#a-在参数j里面select" class="headerlink" title="a) 在参数j里面select"></a>a) 在参数j里面select</h4><p>－返回符合 origin = “LGA” 和 dest = “TPA”这两个条件的 arr_delay列</p>
<pre><code>key(flights)
# [1] &quot;origin&quot; &quot;dest&quot;
flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay)]
#       arr_delay
#    1:         1
#    2:        14
#    3:       -17
#    4:        -4
#    5:       -12
#   ---          
# 1848:        39
# 1849:       -24
# 1850:       -12
# 1851:        21
# 1852:       -11
</code></pre><p>说明：</p>
<pre><code>* 通过基于主键的subset，我们获得了满足 origin == &quot;LGA&quot; 和 dest == “TPA”这两个条件的行索引。
* 现在我们已经获得了这些行的索引，而参数j只请求了 arr_delay列。那么我们简单地从这些行索引中选取 arr_delay列，就像我们在第一讲中做的那样。
* 同以前一样，我们也可以指定 with = FALSE：
flights[.(&quot;LGA&quot;, &quot;TPA&quot;), &quot;arr_delay&quot;, with=FALSE]
</code></pre><h4 id="b-Chaining表达式"><a href="#b-Chaining表达式" class="headerlink" title="b) Chaining表达式"></a>b) Chaining表达式</h4><p>－在上面的基础上，将结果用chaining表达式按降序排列</p>
<pre><code>flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay)][order(-arr_delay)]
#       arr_delay
#    1:       486
#    2:       380
#    3:       351
#    4:       318
#    5:       300
#   ---          
# 1848:       -40
# 1849:       -43
# 1850:       -46
# 1851:       -48
# 1852:       -49
</code></pre><h4 id="c-在参数j里运算"><a href="#c-在参数j里运算" class="headerlink" title="c) 在参数j里运算"></a>c) 在参数j里运算</h4><p>－找出符合 origin = “LGA” 和 dest = “TPA”这两个条件的航班的最大到达延误时间</p>
<pre><code>flights[.(&quot;LGA&quot;, &quot;TPA&quot;), max(arr_delay)]
# [1] 486
</code></pre><p>说明：</p>
<pre><code>* 注意一下，这个结果(486)，就是b)的结果的第一行的值。
</code></pre><h4 id="d-在参数j里使用操作符”-”来sub-assign"><a href="#d-在参数j里使用操作符”-”来sub-assign" class="headerlink" title="d) 在参数j里使用操作符”:=”来sub-assign"></a>d) 在参数j里使用操作符”:=”来sub-assign</h4><p>我们已经在第二讲<a href="http://youngspring1.github.io/post/2016-03-21-datatable2/">语义引用</a>里学习了几个例子了。现在来看看filghts里的 hours列。</p>
<pre><code># get all &apos;hours&apos; in flights
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
</code></pre><p>可以看到，hour列有25种不同的取值。但是0点和24点应该是一样的，我们来把24点全部替换成0点。这次我们用主键来做。</p>
<pre><code>setkey(flights, hour)
key(flights)
# [1] &quot;hour&quot;
flights[.(24), hour := 0L]
key(flights)
# NULL
</code></pre><p>说明：</p>
<pre><code>* 我们首先将 hour列设置为主键。这会将flights按照 hour列重新排序，并且将 hour列标记为主键。
* 现在我们用 .()标记对hour列来subset。我们subset所有值为24的行的索引。
* 对于这些行，我们将主键列的值替换为0.
* 既然我们替换了主键列的值，flights也不再按照 hour列排序了。因此，主键被自动去除了，它被设置为NULL。
</code></pre><p>现在，flights的hour列里，应该没有24了。</p>
<pre><code>flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
</code></pre><h4 id="e-用参数by聚合"><a href="#e-用参数by聚合" class="headerlink" title="e) 用参数by聚合"></a>e) 用参数by聚合</h4><p>我们先将 origin列 和 dest列设置为主键。</p>
<pre><code>setkey(flights, origin, dest)
key(flights)
# [1] &quot;origin&quot; &quot;dest&quot;
</code></pre><p>－获取每个月从“JFK”起飞的航班的最大起飞延误时间，按月排序</p>
<pre><code>ans &lt;- flights[&quot;JFK&quot;, max(dep_delay), keyby=month]
head(ans)
#    month   V1
# 1:     1  881
# 2:     2 1014
# 3:     3  920
# 4:     4 1241
# 5:     5  853
# 6:     6  798
key(ans)
# [1] &quot;month&quot;
</code></pre><p>说明：</p>
<pre><code>* 我们对主键 origin列进行subset，得到了所有起飞机场是“JFK”的行索引。
* 现在我们已经得到这些行的索引了，我们只需要两列－用来分组的month列，和用来计算每组最大值的dep_delay列。data.table的查询都被优化过了，因此在参数i取得的行的基础上，再subset这两列，效率和内存开销都很可观。
* 在subset的时候，我们按month分组，再计算dep_delay列的最大值。
* 我们使用参数keyby来自动将month设置为结果的主键。现在我们理解了为什么叫keyby吧。它使得结果不仅按month列排序，而且将month设置为主键。
</code></pre><h2 id="3-另外两个参数mult和nomatch"><a href="#3-另外两个参数mult和nomatch" class="headerlink" title="3. 另外两个参数mult和nomatch"></a>3. 另外两个参数mult和nomatch</h2><h4 id="a-参数mult"><a href="#a-参数mult" class="headerlink" title="a) 参数mult"></a>a) 参数mult</h4><p>对于每次查询，我们可以通过参数mult，指定所有符合条件的行“all”都被返回，还是只返回第一行“first”或者最后一行“last”。默认是所有的行“all”。<br>－获取符合origin = “JFK” 且 dest = “MIA”的数据的第一行</p>
<pre><code>flights[.(&quot;JFK&quot;, &quot;MIA&quot;), mult=&quot;first&quot;]
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      546         6      853         3         0      AA  N5CGAA   2243    JFK
#    dest air_time distance hour min
# 1:  MIA      157     1089    5  46
</code></pre><p>－获取符合origin = “LGA”或”JFK”或”EWR” 且 dest = “XNA”的数据的最后一行</p>
<pre><code>flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), mult=&quot;last&quot;]
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     5  23     1803       163     2003       148         0      MQ  N515MQ   3553    LGA
# 2:   NA    NA  NA       NA        NA       NA        NA        NA      NA      NA     NA    JFK
# 3: 2014     2   3     1208       231     1516       268         0      EV  N14148   4419    EWR
#    dest air_time distance hour min
# 1:  XNA      158     1147   18   3
# 2:  XNA       NA       NA   NA  NA
# 3:  XNA      184     1131   12   8
</code></pre><p>说明：</p>
<pre><code>* JFK”, “XNA”不匹配flights的任何一条数据，因此返回 NA。
* 再强调一下，参数i里查询语句的第二个主键dest列，&quot;XNA&quot;会被自动补足成跟第一个主键的取值等长，也就是3。
</code></pre><h4 id="b-参数nomatch"><a href="#b-参数nomatch" class="headerlink" title="b) 参数nomatch"></a>b) 参数nomatch</h4><p>我们可以通过参数nomatch，指定在没有找到符合条件的数据的情况下，是返回NA呢，还是跳过（不返回）。<br>－跟前一个例子一样，选取能找到的数据</p>
<pre><code>flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), mult=&quot;last&quot;, nomatch = 0L]
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     5  23     1803       163     2003       148         0      MQ  N515MQ   3553    LGA
# 2: 2014     2   3     1208       231     1516       268         0      EV  N14148   4419    EWR
#    dest air_time distance hour min
# 1:  XNA      158     1147   18   3
# 2:  XNA      184     1131   12   8
</code></pre><p>说明：</p>
<pre><code>* nomatch的默认是是NA。设置 nomatch = 0L 跳过哪些不存在的数据。
* JFK”, “XNA”不匹配flights的任何一条数据，因此就被跳过了。
</code></pre><h2 id="4-二分法搜索-vs-向量扫描"><a href="#4-二分法搜索-vs-向量扫描" class="headerlink" title="4. 二分法搜索 vs 向量扫描"></a>4. 二分法搜索 vs 向量扫描</h2><p>到目前为止，我们学习了如何设置和使用主键来subset。但是它的优点是什么呢？举个例子，除了这么做：</p>
<pre><code># key by origin,dest columns
flights[.(&quot;JFK&quot;, &quot;MIA&quot;)]
</code></pre><p>我们还可以这样做：</p>
<pre><code>flights[origin == &quot;JFK&quot; &amp; dest == &quot;MIA&quot;]
</code></pre><p>一个显而易见的优点是，看上去更短。但是它的优点可不只是这个，事实上，基于二分法搜索的subset非常快速。</p>
<h4 id="a-二分法搜索"><a href="#a-二分法搜索" class="headerlink" title="a) 二分法搜索"></a>a) 二分法搜索</h4><p>为了说明，我们创建一个有两千万行、三列的样本数据，将它的主键设置为x列和y列。</p>
<pre><code>set.seed(2L)
N = 2e7L
DT = data.table(x = sample(letters, N, TRUE), 
                y = sample(1000L, N, TRUE), 
                val=runif(N), key = c(&quot;x&quot;, &quot;y&quot;))
print(object.size(DT), units=&quot;Mb&quot;)
# 381.5 Mb

key(DT)
# [1] &quot;x&quot; &quot;y&quot;
</code></pre><p>DT大约有 380 MB。这不算特别大，但是足够我们体现二分法搜索的优点了。<br>用第一讲<a href="http://youngspring1.github.io/post/2016-03-13-datatable1/">data.table 介绍</a>我们学过的知识，我们可以subset 那些 x = “g” 和 y = 877 的行。</p>
<pre><code>## (1) Usual way of subsetting - vector scan approach
t1 &lt;- system.time(ans1 &lt;- DT[x == &quot;g&quot; &amp; y == 877L])
t1
#    user  system elapsed 
#   0.871   0.022   0.919
head(ans1)
#    x   y       val
# 1: g 877 0.3946652
# 2: g 877 0.9424275
# 3: g 877 0.7068512
# 4: g 877 0.6959935
# 5: g 877 0.9673482
# 6: g 877 0.4842585
dim(ans1)
# [1] 761   3
</code></pre><p>现在我们用主键来试着做一下。</p>
<pre><code>## (2) Subsetting using keys
t2 &lt;- system.time(ans2 &lt;- DT[.(&quot;g&quot;, 877L)])
t2
#    user  system elapsed 
#   0.001   0.000   0.002
head(ans2)
#    x   y       val
# 1: g 877 0.3946652
# 2: g 877 0.9424275
# 3: g 877 0.7068512
# 4: g 877 0.6959935
# 5: g 877 0.9673482
# 6: g 877 0.4842585
dim(ans2)
# [1] 761   3

identical(ans1$val, ans2$val)
# [1] TRUE
</code></pre><p>(2)比(1)快了460倍！</p>
<h4 id="b-为什么用主键subset能这么快"><a href="#b-为什么用主键subset能这么快" class="headerlink" title="b) 为什么用主键subset能这么快?"></a>b) 为什么用主键subset能这么快?</h4><p>为了理解这些，我们先看第一种方法(1)向量扫描。</p>
<pre><code>向量扫描
* 在所有两千条数据中，逐行搜索 x列里值为“g”的行。这会生成一个有两千行的逻辑向量，根据和x列的批评结果，它每个元素的取值可能是TRUE, FALSE 以及 NA。
* 相似的，在所有两千条数据中，逐行搜索 y列里值为“877”的行，再保存在另一个逻辑向量里面。
* 操作符&quot;&amp;&quot;对上面两个逻辑向量进行“且”运算，返回结果为TRUE的行
这就是所谓的“向量扫描”。效率非常低，特别是数据量很大、需要重复subset的时候。因为它每次不得不对整个数据全盘扫描。
</code></pre><p>现在我们开看看第二种方法(2)二分法搜索。回忆一下前面“a)什么是主键”里的定义，根据主键列重新排序。既然数据被排序了，我们就不需要再对整个数据进行扫描。我们用二分法搜索的时间开销是 O(log n)，而向量扫描的时间开销是 O(n)，其中n是data.table的行数。</p>
<pre><code>二分法搜索
这里有一个简单的示例。看看下面这组排过序的数字：
1, 5, 10, 19, 22, 23, 30
假设我们希望找到数字1的位置，用二分法搜索（因为这组数字是排过序的），我们是这么做的：
* 从中间的数开始，它是19，不是1，而且 1&lt;19。
* 既然我们要找的数字1小于19，那它应该排在19前面。所以我们可以无视19后面的那一半数据，因为它们都大于19.
* 现在我们的数据只剩下1, 5, 10。再找到中间的数5，它不是1，而且 1&lt;5。
* 现在我们的数据只剩下1。符合条件。这就是我们要找的数。
相反的，向量扫描需要扫描所有的数字，在这个例子中是7。
</code></pre><p>显而易见的，我们每次搜索的时候，搜索量都是原先的一半。这就是为什么基于二分法搜索的subset是如此的快。<br>因为data.table的行在内存中是连续存储的，这种subset的操作也很节省缓存，这有利于处理速度。<br>另外，既然我们不需要创建超大（跟原数据有同样多的行）的逻辑向量，就能取得匹配的行的索引，这种subset也能节省内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一讲，我们学习了通过设置主键来subset行。设置主键使用了二分法搜索似的subset的操作变得惊人的快。特别的，我们学习了如何：</p>
<pre><code>* 设置主键，并使用主键subset行。
* 更快的在参数i里通过主键subset行的索引。
* 将主键和参数j、参数by一起使用。注意参数j和参数by的使用方法和以前一样。
</code></pre><p>我们大概不需要用主键来进行聚合的操作，除非数据了极其巨大，使得我们需要重复地做很多次subset，这就会让效果变得很醒目。<br>然而，当连结两个data.table的时候，设置主键是必要的。这是下一讲的主题。<br>我们会详细讲解根据主键列来连结两个data.table。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-03-22-datatable3/" data-id="cjqj71z6g0031l3w86oem36kq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/R/">R</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-table/">data.table</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-21-datatable2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-03-21-datatable2/" class="article-date">
  <time datetime="2016-03-21T03:56:45.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/data-table教程/">data.table教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-03-21-datatable2/">data.table 教程2－语义引用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目录：   </p>
<ol>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-13-datatable1/">data.table 介绍</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-21-datatable2/">语义引用</a>      </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-22-datatable3/">主键、基于二分法搜索的subset</a>    </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-02-datatable4/">二次索引和自动索引</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-08-datatable5/">数据拆分和合并</a>   </li>
</ol>
<p>原文地址：<br><a href="https://github.com/Rdatatable/data.table/wiki/Getting-started" target="_blank" rel="external">data.table/wiki/Getting-started</a></p>
<hr>
<p>本教程讨论data.table的语义引用，它允许通过引用来add/update/delete列，然后通过参数i和by结合。它主要给那些熟悉data.table语法、知道如何subset行／select列／分组的人使用。如果你对这些不熟悉，请学习上一讲 <a href="http://youngspring1.github.io/post/2016-03-13-datatable1/">data.table 介绍</a>。   </p>
<hr>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>我们继续使用上一讲中使用的航班信息flights。</p>
<pre><code>flights &lt;- fread(&quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/    flights/NYCflights14/flights14.csv&quot;)
flights
#         year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
#      1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
#      2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
#      3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
#      4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
#      5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
#     ---                                                                                      
# 253312: 2014    10  31     1459         1     1747       -30         0      UA  N23708   1744
# 253313: 2014    10  31      854        -5     1147       -14         0      UA  N33132   1758
# 253314: 2014    10  31     1102        -8     1311        16         0      MQ  N827MQ   3591
# 253315: 2014    10  31     1106        -4     1325        15         0      MQ  N511MQ   3592
# 253316: 2014    10  31      824        -5     1045         1         0      MQ  N813MQ   3599
#         origin dest air_time distance hour min
#      1:    JFK  LAX      359     2475    9  14
#      2:    JFK  LAX      363     2475   11  57
#      3:    JFK  LAX      351     2475   19   2
#      4:    LGA  PBI      157     1035    7  22
#      5:    JFK  LAX      350     2475   13  47
#     ---                                       
# 253312:    LGA  IAH      201     1416   14  59
# 253313:    EWR  IAH      189     1400    8  54
# 253314:    LGA  RDU       83      431   11   2
# 253315:    LGA  DTW       75      502   11   6
# 253316:    LGA  SDF      110      659    8  24
dim(flights)
# [1] 253316     17
</code></pre><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这一讲，我们会：   </p>
<pre><code>* 简要讨论“语义引用”，然后比较操作符“:=”的两种不同的形式。
* 学习如何在参数j里面使用操作符“:=”来add/update/delete列，如何与参数i和by相结合。
* 了解操作符“:=”的副作用，并学习如何用 copy() 来避免这些副作用。
</code></pre><h2 id="1-语义引用"><a href="#1-语义引用" class="headerlink" title="1. 语义引用"></a>1. 语义引用</h2><p>到目前为止，我们学习到的所有的操作都会生成一个新的数据集。接下来，我们会学习如何在原来数据集的基础上，添加／更新／删除那些已经存在的列。      </p>
<h4 id="a-背景"><a href="#a-背景" class="headerlink" title="a) 背景"></a>a) 背景</h4><p>在学习语义引用之前，我们先来看下面这个data.frame：   </p>
<pre><code>DF = data.frame(ID = c(&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;c&quot;), a = 1:6, b = 7:12, c=13:18)
DF
#   ID a  b  c
# 1  b 1  7 13
# 2  b 2  8 14
# 3  b 3  9 15
# 4  a 4 10 16
# 5  a 5 11 17
# 6  c 6 12 18
</code></pre><p>当我们执行下面的命令：   </p>
<pre><code>DF$c &lt;- 18:13               # (1) -- replace entire column
# or
DF$c[DF$ID == &quot;b&quot;] &lt;- 15:13 # (2) -- subassign in column &apos;c&apos;
</code></pre><p>在R语言V3.1之前的版本里，上面这两种方法都会导致对整个data.frame的深度拷贝[^1]。而且还会拷贝多次[^2]。为了提高效率避免冗余操作，data.tabel使用了操作符”:=”。R里面本来就有定义了这个操作符，但却没有使用[^3]。<br>[^1]:<a href="http://r.789695.n4.nabble.com/speeding-up-perception-td3640920.html#a3646694" target="_blank" rel="external">Speeding up perception</a><br>[^2]:<a href="http://stackoverflow.com/questions/23898969/is-data-really-copied-four-times-in-rs-replacement-functions" target="_blank" rel="external">Is data really copied four times in R’s replacement functions?</a><br>[^3]:<a href="http://stackoverflow.com/questions/7033106/why-has-data-table-defined-rather-than-overloading" target="_blank" rel="external">Why has data.table defined := rather than overloading &lt;-?</a></p>
<p>在R语言V3.1之前的版本里，方法(1)只做影子拷贝，处理性能有了很大提升。然而，方法(2)还是会做深度拷贝。这就意味着，对于同样的查询语句，想要选取的列越多，需要做的深度拷贝就越多。   </p>
<pre><code>影子拷贝 vs 深度拷贝
影子拷贝，只是一份指向列的指针向量的拷贝，它会随着data.frame或者data.table的变化而变化。但在内存里，数据不是真的被复制了。   
深度拷贝，正相反，它会复制整个数据，并且保存在内存里。
</code></pre><p>如果使用操作符”:=”，不管在R语言的什么版本里，不管是方法(1)还是方法(2)，都不会再拷贝。这是因为，操作符”:=”通过引用更新列。</p>
<h4 id="b-操作符“-”"><a href="#b-操作符“-”" class="headerlink" title="b) 操作符“:=”"></a>b) 操作符“:=”</h4><p>在参数j中，操作符“:=”有两种使用方法：<br>a.左右等式的形式</p>
<pre><code>DT[, c(&quot;colA&quot;, &quot;colB&quot;, ...) := list(valA, valB, ...)]

# when you have only one column to assign to you 
# can drop the quotes and list(), for convenience
DT[, colA := valA]
</code></pre><p>b.函数形式</p>
<pre><code>DT[, `:=`(colA = valA, # valA is assigned to colA
      colB = valB, # valB is assigned to colB
      ...
)]
</code></pre><p>注意：</p>
<pre><code>上面的两个例子只是用来说明使用的形式，并不是实际可以运行的代码示例。我们会在下一节中，用航班信息flight的data.table来举例说明。
</code></pre><p>说明：</p>
<pre><code>* 形式(a)比较容易编码，特别是，事先不知道需要被赋值的列的时候。
* 相对而言，形式(b)更加趁手，如果你愿意追加点注释😄。
* 操作符“:=”没有返回值。
* 既然参数j里面可以使用操作符“:=”，那么，就像上一讲中学习到的内容，我们可以和参数i和参数by一起，做些聚合的运算。
</code></pre><p>在上面两种形式里，注意我们没有把运算的结果赋值给一个变量。因为完全没必要。我们直接更新data.table。让我们通过一些例子来说明。<br>在接下来的教程里，我们对航班信息flight，这个data.table来示例。   </p>
<h2 id="2-添加／更新／删除列"><a href="#2-添加／更新／删除列" class="headerlink" title="2. 添加／更新／删除列"></a>2. 添加／更新／删除列</h2><h4 id="a-添加列"><a href="#a-添加列" class="headerlink" title="a) 添加列"></a>a) 添加列</h4><p>－如何对每次航班，添加 speed 和 total delay 两列</p>
<pre><code>flights[, `:=`(speed = distance / (air_time/60), # speed in km/hr
           delay = arr_delay + dep_delay)]       # delay in minutes
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed delay
# 1:  LAX      359     2475    9  14 413.6490    27
# 2:  LAX      363     2475   11  57 409.0909    10
# 3:  LAX      351     2475   19   2 423.0769    11
# 4:  PBI      157     1035    7  22 395.5414   -34
# 5:  LAX      350     2475   13  47 424.2857     3
# 6:  LAX      339     2454   18  24 434.3363     4

## alternatively, using the &apos;LHS := RHS&apos; form
# flights[, c(&quot;speed&quot;, &quot;delay&quot;) := list(distance/(air_time/60), arr_delay + dep_delay)]
</code></pre><p>注意：</p>
<pre><code>* 我们不需要将结果赋值给 flights。
* flights 现在包含了刚刚追加的两列。这就是我们说的“添加列”。
* 我们用函数形式，这样就可以在旁边写注释了。当然也可以用等式的形式。
</code></pre><h4 id="b-更新列（sub-assign）"><a href="#b-更新列（sub-assign）" class="headerlink" title="b) 更新列（sub-assign）"></a>b) 更新列（sub-assign）</h4><p>现在留意一下 fligths 里的 hour列。</p>
<pre><code># get all &apos;hours&apos; in flights
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
</code></pre><p>可以看到，hour列有25种不同的取值。但是0点和24点应该是一样的，我们来把24点全部替换成0点。<br>－将 hour=24 替换成0</p>
<pre><code># subassign by reference
flights[hour == 24L, hour := 0L]
</code></pre><p>说明：</p>
<pre><code>* 就像在上一讲中学习的一样，我们可以使用参数i 和 参数j里的操作符“:=”一起使用。
* 只有满足了参数i 中指定的条件 hour == 24L 的那些列，它们的值会被替换成0。
* 操作符“:=”没有返回值。有时候需要查看运行的结果，我们可以在查询语句的最后加一对方括号[]，来达到这个目的。
flights[hour == 24L, hour := 0L][]
#         year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
#      1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
#      2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
#      3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
#      4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
#      5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
#     ---                                                                                      
# 253312: 2014    10  31     1459         1     1747       -30         0      UA  N23708   1744
# 253313: 2014    10  31      854        -5     1147       -14         0      UA  N33132   1758
# 253314: 2014    10  31     1102        -8     1311        16         0      MQ  N827MQ   3591
# 253315: 2014    10  31     1106        -4     1325        15         0      MQ  N511MQ   3592
# 253316: 2014    10  31      824        -5     1045         1         0      MQ  N813MQ   3599
#         origin dest air_time distance hour min    speed delay
#      1:    JFK  LAX      359     2475    9  14 413.6490    27
#      2:    JFK  LAX      363     2475   11  57 409.0909    10
#      3:    JFK  LAX      351     2475   19   2 423.0769    11
#      4:    LGA  PBI      157     1035    7  22 395.5414   -34
#      5:    JFK  LAX      350     2475   13  47 424.2857     3
#     ---                                                      
# 253312:    LGA  IAH      201     1416   14  59 422.6866   -29
# 253313:    EWR  IAH      189     1400    8  54 444.4444   -19
# 253314:    LGA  RDU       83      431   11   2 311.5663     8
# 253315:    LGA  DTW       75      502   11   6 401.6000    11
# 253316:    LGA  SDF      110      659    8  24 359.4545    -4
</code></pre><p>现在我们再来看下 hour列。</p>
<pre><code># check again for &apos;24&apos;
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
</code></pre><h4 id="c-删除列"><a href="#c-删除列" class="headerlink" title="c) 删除列"></a>c) 删除列</h4><p>－删除 delay列</p>
<pre><code>flights[, c(&quot;delay&quot;) := NULL]
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed
# 1:  LAX      359     2475    9  14 413.6490
# 2:  LAX      363     2475   11  57 409.0909
# 3:  LAX      351     2475   19   2 423.0769
# 4:  PBI      157     1035    7  22 395.5414
# 5:  LAX      350     2475   13  47 424.2857
# 6:  LAX      339     2454   18  24 434.3363

## or using the functional form
# flights[, `:=`(delay = NULL)]
</code></pre><p>说明：</p>
<pre><code>* 将一列赋值为 NULL，就会删除那一列。删除立即生效。
* 使用左右等式的形式的时候，除了指定列名，我们也可以指定列号。但还是忘记吧，指定列名是个好的编码习惯。
* 为了方便，如果只需要删除一列，可以去掉 c(&quot;&quot;)，只指定列名，像这样：
flights[, delay := NULL]
这和上面的方法是等效的。
</code></pre><h4 id="d-“-”和分组"><a href="#d-“-”和分组" class="headerlink" title="d) “:=”和分组"></a>d) “:=”和分组</h4><p>我们已经在b)里面学习了如何跟参数i 一起使用，现在我们来学习如何跟参数by 一起使用。<br>－如何追加一列，用来保存某对起飞／到达机场间的最快飞行速度</p>
<pre><code>flights[, max_speed := max(speed), by=.(origin, dest)]
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed max_speed
# 1:  LAX      359     2475    9  14 413.6490  526.5957
# 2:  LAX      363     2475   11  57 409.0909  526.5957
# 3:  LAX      351     2475   19   2 423.0769  526.5957
# 4:  PBI      157     1035    7  22 395.5414  517.5000
# 5:  LAX      350     2475   13  47 424.2857  526.5957
# 6:  LAX      339     2454   18  24 434.3363  518.4507
</code></pre><p>说明：</p>
<pre><code>* 我们用操作符“:=”追加了一列 max_speed。
* 和上一讲学习到的内容一样，我们将所有数据进行分组。对于每组数据，计算最快速度。对于一对机场，这个最快速度是唯一的。循环复制这个值到一个list，直到跟该组数据的行数一样多。航班信息flights会被就地更新，不会因拷贝浪费内存空间。
* 和上一讲学习到的内容一样，我们也可以对参数by指定一个字符型的向量，形式是这样：
by = c(&quot;origin&quot;, &quot;dest&quot;)
</code></pre><h4 id="e-“-”和复数列"><a href="#e-“-”和复数列" class="headerlink" title="e) “:=”和复数列"></a>e) “:=”和复数列</h4><p>－如何再追加两列，用于保存每个月的最大起飞延误时间dep_delay 和到达延误时间arr_delay<br>小提示：要用到上一讲学习到的 .SD</p>
<pre><code>in_cols  = c(&quot;dep_delay&quot;, &quot;arr_delay&quot;)
out_cols = c(&quot;max_dep_delay&quot;, &quot;max_arr_delay&quot;)
flights[, c(out_cols) := lapply(.SD, max), by = month, .SDcols = in_cols]
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed max_speed max_dep_delay max_arr_delay
# 1:  LAX      359     2475    9  14 413.6490  526.5957           973           996
# 2:  LAX      363     2475   11  57 409.0909  526.5957           973           996
# 3:  LAX      351     2475   19   2 423.0769  526.5957           973           996
# 4:  PBI      157     1035    7  22 395.5414  517.5000           973           996
# 5:  LAX      350     2475   13  47 424.2857  526.5957           973           996
# 6:  LAX      339     2454   18  24 434.3363  518.4507           973           996
</code></pre><p>说明：</p>
<pre><code>* 为了更好的可读性，我们使用了左右等式的形式。我们事先保存了输入的列名到变量in_cols，作为 .SDcols的参数。我们还事先保存了输出的列名到变量out_cols，作为左边的表达式。
* 注意一下，我们在c)里面讲过，如果只需要追加一列，那么可以省略双引号，只指定列名。但是这里我们需要指定 c(out_cols) 或者 (out_cols)。 
* 左右等式的形式，允许我们操作复数的列。在右边的表达式里，为了对指定在 .SDcols 里的列计算最大值，我们使用了R的基础函数 lapply()。这些我们在上一讲中都学习过了。它返回有两个元素的list，包含每组的 dep_delay 和 arr_delay 这两列的最大值。
</code></pre><p>在进行下一节的学习之前，让我们删除刚刚追加的几列：speed, max_speed, max_dep_delay 和 max_arr_delay。</p>
<pre><code># RHS gets automatically recycled to length of LHS
flights[, c(&quot;speed&quot;, &quot;max_speed&quot;, &quot;max_dep_delay&quot;, &quot;max_arr_delay&quot;) := NULL]
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min
# 1:  LAX      359     2475    9  14
# 2:  LAX      363     2475   11  57
# 3:  LAX      351     2475   19   2
# 4:  PBI      157     1035    7  22
# 5:  LAX      350     2475   13  47
# 6:  LAX      339     2454   18  24
</code></pre><h2 id="3-“-”和copy"><a href="#3-“-”和copy" class="headerlink" title="3. “:=”和copy()"></a>3. “:=”和copy()</h2><p>操作符“:=”会更新原数据。和我们之前学过的功能不同，有时候，我们希望更新原数据。但有时候，我们不想更新原数据，这种情况下，我们可以用函数 copy()。</p>
<h4 id="a-“-”的副作用"><a href="#a-“-”的副作用" class="headerlink" title="a) “:=”的副作用"></a>a) “:=”的副作用</h4><p>如果我们想创建一个函数，用于返回每个月的最快速度。但是此时，我们也想对 flights 追加一列 speed。可以像下面这样做：</p>
<pre><code>foo &lt;- function(DT) {
  DT[, speed := distance / (air_time/60)]
  DT[, .(max_speed = max(speed)), by=month]
}
ans = foo(flights)
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min    speed
# 1:  LAX      359     2475    9  14 413.6490
# 2:  LAX      363     2475   11  57 409.0909
# 3:  LAX      351     2475   19   2 423.0769
# 4:  PBI      157     1035    7  22 395.5414
# 5:  LAX      350     2475   13  47 424.2857
# 6:  LAX      339     2454   18  24 434.3363
head(ans)
#    month max_speed
# 1:     1  535.6425
# 2:     2  535.6425
# 3:     3  549.0756
# 4:     4  585.6000
# 5:     5  544.2857
# 6:     6  608.5714
</code></pre><p>说明：</p>
<pre><code>* 注意一个新的列 speed 被追加到 flight 里了。这时因为我们用了操作符“:=”。既然 DT 和flights都指向内存中同一个对象，对 DT 的操作，也会对 flights 生效。
* 返回值 ans 包含了每月的最快速度。
</code></pre><h4 id="b-函数copy"><a href="#b-函数copy" class="headerlink" title="b) 函数copy()"></a>b) 函数copy()</h4><p>在前面一节，我们利用了操作符“:=”的副作用来更新原数据。但是不会一直希望这样又是，我们希望给函数传递data.table参数，使用操作符“:=”的功能，但是不想改变原数据。我们可以用函数 copy() 来做到这一点。</p>
<pre><code>函数 copy() 对输入参数进行深度拷贝，因此对副本做的所有更新操作，都不会对原数据生效。
</code></pre><p>函数 copy() 有两个不可或缺的特点：<br>1.和前一节内容的情形相反，我们可能不希望传递的参数被修改。举个例子，考虑前一节中，我们不想修改 flights的内容。<br>我们先删掉前一节中，追加的 speed列：   </p>
<pre><code>flights[, speed := NULL]   
</code></pre><p>现在，我们可以像下面这样做：</p>
<pre><code>foo &lt;- function(DT) {
  DT &lt;- copy(DT)                             ## deep copy
  DT[, speed := distance / (air_time/60)]    ## doesn&apos;t affect &apos;flights&apos;
  DT[, .(max_speed = max(speed)), by=month]
}
ans &lt;- foo(flights)
head(flights)
#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin
# 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK
# 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK
# 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK
# 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA
# 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK
# 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR
#    dest air_time distance hour min
# 1:  LAX      359     2475    9  14
# 2:  LAX      363     2475   11  57
# 3:  LAX      351     2475   19   2
# 4:  PBI      157     1035    7  22
# 5:  LAX      350     2475   13  47
# 6:  LAX      339     2454   18  24
head(ans)
#    month max_speed
# 1:     1  535.6425
# 2:     2  535.6425
# 3:     3  549.0756
# 4:     4  585.6000
# 5:     5  544.2857
# 6:     6  608.5714
</code></pre><p>说明：</p>
<pre><code>* 使用函数 copy() 不会更新 flights。它现在不包含 speed列。
* 返回值 ans 包含了每月的最快速度。
然而，我们可以使用影子拷贝来代替深度拷贝，来大幅度提高这个操作的效率。事实上，我们希望在 Data.Table的V1.9.8的版本里提供这个功能。我们会在data.table的设计里面继续讨论这个内容。
</code></pre><p>Data.Table V1.9.8 相关资料：<br><a href="https://github.com/Rdatatable/data.table/issues/617" target="_blank" rel="external">Copy-on-:= at column level, DT[,list(…)] shallow copy and add cols to shallow(DT, cols)</a>   </p>
<p>2.当我们将列名保存在变量里的时候，比如：DT_n = names(DT)，然后再对 DT 添加／更新／删除列，操作符“:=”也会更新变量 DT_n，除非我们运行 copy(names(DT))。</p>
<pre><code>DT = data.table(x=1, y=2)
DT_n = names(DT)
DT_n
# [1] &quot;x&quot; &quot;y&quot;

## add a new column by reference
DT[, z := 3]

## DT_n also gets updated
DT_n
# [1] &quot;x&quot; &quot;y&quot; &quot;z&quot;

## use `copy()`
DT_n = copy(names(DT))
DT[, w := 4]

## DT_n doesn&apos;t get updated
DT_n
# [1] &quot;x&quot; &quot;y&quot; &quot;z&quot;
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>操作符“:=”
* 操作符“:=”用于添加／更新／删除列。
* 我们也学习了如何跟参数i和参数by一起使用，就像在第一讲中学习的那样。同样，我们也可以使用 keyby，可以用方括号 [] 将操作连结起来，可以给参数by 指定表达式。
* 我们可以利用操作符“:=”更新原数据，也可以用函数 copy() 来避免更新原数据。
</code></pre><p>到目前为止，我们学习了好多参数j相关的知识，知道了参数i、参数j和参数by如何一起使用。下一讲<a href="http://youngspring1.github.io/post/2016-03-22-datatable3/">主键、基于二分法搜索的subset</a>，我们将注意力回到参数i上，来做一些通过主键的超快速的排序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-03-21-datatable2/" data-id="cjqj71z6e0030l3w841br1wo4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/R/">R</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-table/">data.table</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-20-bike" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/2016-03-20-bike/" class="article-date">
  <time datetime="2016-03-20T06:10:24.000Z" itemprop="datePublished">2016-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生活/">生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/2016-03-20-bike/">单车一周旅行计划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>D1：南京–溧阳市  110km  </p>
<p>很容易</p>
<p>D2：溧阳市–安吉县 115km </p>
<p>容易</p>
<p>D3：安吉县–太阳镇  105km</p>
<p>如果走天荒坪，爬山，难  </p>
<p>如果绕过西天目，中等</p>
<p>D4：太阳镇–岛石镇 103km</p>
<p>翻山，华浪线，难</p>
<p>D5：岛石镇–十字镇 130km</p>
<p>走南极，宁国，中等</p>
<p>（可以考虑走荆州公路提高难度）</p>
<p>D6：十字镇–南京  137km</p>
<p>容易</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://youngspring1.github.io/2016/2016-03-20-bike/" data-id="cjqj71z58001dl3w83qwcxnoo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单车/">单车</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/旅行/">旅行</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/data-table教程/">data.table教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据分析笔记/">数据分析笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/新知/">新知</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习的数学基础/">机器学习的数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Excel/">Excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kevin-Kelly/">Kevin Kelly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCS/">LCS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSS-Lisence/">OSS Lisence</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/R/">R</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/The-Inevitable/">The Inevitable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/career/">career</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/class/">class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-table/">data.table</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/evalution/">evalution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github-pages-blog/">github pages blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hugo/">hugo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/joel-on-software/">joel on software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mode/">mode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shiny-server/">shiny server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software/">software</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeof/">typeof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/west-world/">west world</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlrd/">xlrd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/专注/">专注</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人类简史/">人类简史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/入门教程/">入门教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单车/">单车</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/塞尔达传说/">塞尔达传说</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/孔庙孔府孔林/">孔庙孔府孔林</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小说/">小说</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/归一化/">归一化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/想法/">想法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感受/">感受</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敦煌/">敦煌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据分析/">数据分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/旅行/">旅行</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日本/">日本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日记/">日记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/有顶天家族/">有顶天家族</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概率/">概率</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泰山/">泰山</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/洛阳/">洛阳</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏/">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/猫/">猫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活感受/">生活感受</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电影/">电影</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/碎碎念/">碎碎念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/穿越/">穿越</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单工作/">简单工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/美食/">美食</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/背景知识/">背景知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/西安/">西安</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/诗/">诗</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语音识别/">语音识别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/赛车/">赛车</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Excel/" style="font-size: 10px;">Excel</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Kevin-Kelly/" style="font-size: 10px;">Kevin Kelly</a> <a href="/tags/LCS/" style="font-size: 10px;">LCS</a> <a href="/tags/OSS-Lisence/" style="font-size: 10px;">OSS Lisence</a> <a href="/tags/R/" style="font-size: 20px;">R</a> <a href="/tags/The-Inevitable/" style="font-size: 10px;">The Inevitable</a> <a href="/tags/career/" style="font-size: 10px;">career</a> <a href="/tags/class/" style="font-size: 10px;">class</a> <a href="/tags/data-table/" style="font-size: 17.5px;">data.table</a> <a href="/tags/design/" style="font-size: 10px;">design</a> <a href="/tags/evalution/" style="font-size: 10px;">evalution</a> <a href="/tags/github-pages-blog/" style="font-size: 10px;">github pages blog</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hugo/" style="font-size: 10px;">hugo</a> <a href="/tags/joel-on-software/" style="font-size: 10px;">joel on software</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/mode/" style="font-size: 10px;">mode</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/shiny-server/" style="font-size: 12.5px;">shiny server</a> <a href="/tags/software/" style="font-size: 12.5px;">software</a> <a href="/tags/typeof/" style="font-size: 10px;">typeof</a> <a href="/tags/west-world/" style="font-size: 10px;">west world</a> <a href="/tags/xlrd/" style="font-size: 10px;">xlrd</a> <a href="/tags/专注/" style="font-size: 10px;">专注</a> <a href="/tags/人类简史/" style="font-size: 10px;">人类简史</a> <a href="/tags/入门教程/" style="font-size: 10px;">入门教程</a> <a href="/tags/单车/" style="font-size: 10px;">单车</a> <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/塞尔达传说/" style="font-size: 10px;">塞尔达传说</a> <a href="/tags/孔庙孔府孔林/" style="font-size: 10px;">孔庙孔府孔林</a> <a href="/tags/小说/" style="font-size: 10px;">小说</a> <a href="/tags/归一化/" style="font-size: 10px;">归一化</a> <a href="/tags/想法/" style="font-size: 12.5px;">想法</a> <a href="/tags/感受/" style="font-size: 10px;">感受</a> <a href="/tags/敦煌/" style="font-size: 10px;">敦煌</a> <a href="/tags/数据分析/" style="font-size: 10px;">数据分析</a> <a href="/tags/旅行/" style="font-size: 17.5px;">旅行</a> <a href="/tags/日本/" style="font-size: 15px;">日本</a> <a href="/tags/日记/" style="font-size: 10px;">日记</a> <a href="/tags/有顶天家族/" style="font-size: 10px;">有顶天家族</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/概率/" style="font-size: 12.5px;">概率</a> <a href="/tags/泰山/" style="font-size: 10px;">泰山</a> <a href="/tags/洛阳/" style="font-size: 10px;">洛阳</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/游戏/" style="font-size: 12.5px;">游戏</a> <a href="/tags/猫/" style="font-size: 10px;">猫</a> <a href="/tags/生活感受/" style="font-size: 10px;">生活感受</a> <a href="/tags/电影/" style="font-size: 10px;">电影</a> <a href="/tags/碎碎念/" style="font-size: 10px;">碎碎念</a> <a href="/tags/穿越/" style="font-size: 10px;">穿越</a> <a href="/tags/简单工作/" style="font-size: 10px;">简单工作</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/美食/" style="font-size: 10px;">美食</a> <a href="/tags/背景知识/" style="font-size: 10px;">背景知识</a> <a href="/tags/西安/" style="font-size: 10px;">西安</a> <a href="/tags/诗/" style="font-size: 10px;">诗</a> <a href="/tags/语音识别/" style="font-size: 10px;">语音识别</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/赛车/" style="font-size: 10px;">赛车</a> <a href="/tags/转载/" style="font-size: 10px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/20190105-repost/">转载：一份多么美好的长期租约|张宇凌</a>
          </li>
        
          <li>
            <a href="/2019/2019-01-01-happynewyear/">又是新的一年</a>
          </li>
        
          <li>
            <a href="/2018/2018-04-15-tour-de-hyrule/">海拉鲁大陆旅行指南</a>
          </li>
        
          <li>
            <a href="/2017/2017-10-20-parse-date-in-xlsx/">用 Python 解析 Excel 发现的小坑</a>
          </li>
        
          <li>
            <a href="/2017/2017-10-15-hexo/">迁移博客系统到hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 youngspring1<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>