<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2016/2016-05-10-zuozhuan" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/10/2016/2016-05-10-zuozhuan/" class="article-date">
  <time datetime="2016-05-10T07:20:31.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/2016/2016-05-10-zuozhuan/">眼前：漫游在《左传》的世界</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>后人看历史的时候，不可避免地站在上帝视角思考问题。<br>读史记，一个人将来能够成就什么，从一开始就预设好了。<br>又或者大部分历史书，一个王朝如何兴起、成长、强盛、衰落，仿佛就是按照剧本来演的。   </p>
<p>而实际上，当时的人，哪知道后来会发生什么，哪知道做了某件事情的结果，甚至不知道大国的另外一个角落，此刻发生了什么。</p>
<p>就好像看比赛直播，心情各种复杂，岂止是晚间新闻报道里三言两语能够概括的。</p>
<hr>
<p>亚马逊链接：<a href="https://www.amazon.cn/gp/product/B01AU85S80/ref=od_aui_detailpages00?ie=UTF8&amp;psc=1" target="_blank" rel="external">眼前：漫游在《左传》的世界</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/10/2016/2016-05-10-zuozhuan/" data-id="cj8lnyu250003xuw83t4145fi" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-05-10-xianluoyang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/10/2016/2016-05-10-xianluoyang/" class="article-date">
  <time datetime="2016-05-10T07:16:19.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/生活/">生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/2016/2016-05-10-xianluoyang/">2016五月 西安洛阳行记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="西安印象"><a href="#西安印象" class="headerlink" title="西安印象"></a>西安印象</h4><p>很热闹的城市，超多游人。<br>吃的东西，还是自己找小巷子更好。<br>市区或者有名的文保单位明显不及山西的高质量。去了大雁塔50门票+30登塔，顿时发现佛光寺就算收150页不算贵。（啊啊啊，可怜我硬盘数据丢失，两三年的照片都没了）<br>最后发张图证明来过西安：<br><img src="http://7xrjai.com1.z0.glb.clouddn.com/20160522-dyt.JPG" alt="大雁塔">   </p>
<h4 id="洛阳印象"><a href="#洛阳印象" class="headerlink" title="洛阳印象"></a>洛阳印象</h4><p>超棒的小城市，特别喜欢当地人生活的小巷子，特别有人气！（当然让我自己去住我是不愿意的）<br>可为什么大街上都是医院和卖成人用品的店呢？<br>白马寺和龙门石窟都超赞！<br><img src="http://7xrjai.com1.z0.glb.clouddn.com/20160522-bms.JPG" alt="白马寺"><br><img src="http://7xrjai.com1.z0.glb.clouddn.com/20160522-lmsk.JPG" alt="龙门石窟">   </p>
<h4 id="郑州印象"><a href="#郑州印象" class="headerlink" title="郑州印象"></a>郑州印象</h4><p>脏乱差。要不是这次河南博物院大修，我是不愿意来第二次的。   </p>
<h4 id="多余的话"><a href="#多余的话" class="headerlink" title="多余的话"></a>多余的话</h4><p>那些被技术淘汰的事物：旅游地图／景区照相<br>以前到达一个地方，总会立马买一张当地的地图。是的，对我来说，这就是外部世界的入口。而如今大家早已经用手机地图了，在火车站／汽车站，还是能够遇到不少这样的老奶奶，举着地图，“5元一份”，看到这样的情景总是很纳闷，难道没有子女提醒他们，现在大部分人已经不买这个了吗？<br>同样还有景区快照。在以前数码相机还没有普及的时候，无可厚非。但是现在还大规模的打出“5分钟快照”的旗号，你们的世界就不更新吗？除非占据了特别好的机位（只有这个点才能拍到全景，而且我占了，旅游者自己拍不到），或者抓住了时机（比如坐过山车时）。   </p>
<p>停车场<br>秦始皇兵马俑附近农家跑到马路上招揽停车的游人，口号是“只要5块，景区10块”。你们其实没有想到，他们不在乎这五块十块钱，他们在乎的是能不能少走两步路，不谢。   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/10/2016/2016-05-10-xianluoyang/" data-id="cj8lnyu230002xuw807bzyg5y" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-05-10-R04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/10/2016/2016-05-10-R04/" class="article-date">
  <time datetime="2016-05-10T03:44:08.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据分析笔记/">数据分析笔记</a>►<a class="article-category-link" href="/categories/数据分析笔记/新知/">新知</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/2016/2016-05-10-R04/">MIT:The Analytics Edge 笔记04－决策树和随机森林</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MIT课程 <a href="https://courses.edx.org/courses/course-v1:MITx+15.071x_3+1T2016/info" target="_blank" rel="external">15.071x The Analytics Edge</a> 第四单元的学习记录。</p>
<hr>
<h2 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h2><p>第四单元的主题是决策树和随机森林。</p>
<h3 id="1-理论"><a href="#1-理论" class="headerlink" title="1.理论"></a>1.理论</h3><h4 id="CART-classification-and-regression-trees"><a href="#CART-classification-and-regression-trees" class="headerlink" title="CART(classification and regression trees)"></a>CART(classification and regression trees)</h4><h6 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h6><p>自变量是决策树上的节点(splits)。但是注意，不是每个自变量都有一个节点；也就是说，有的自变量有多个节点(随着取值的不同，导致因变量的结果也不同)，有的自变量没有节点(对因变量影响很小)。<br>因变量是决策树上的叶子/终端(leaves/nodes)。此图上的因变量的取值是0或者1。<br>在各个节点，根据各个自变量的取值，最终到达叶子节点，也就得到了因变量的取值。<br>注意，决策树的左边，节点的判断语句总是为True／Yes，右边节点的判断语句总是为False／No。<br><img src="http://7xrjai.com1.z0.glb.clouddn.com/20160517-tree-Rplot.png" alt="tree"><br>最左的分支表示，如果 LowerCou=lbr 且 Responde=CRI 且 Petition=CIT，那么因变量的取值为0。<br>最右的分支表示，如果 LowerCou!=lbr 且 Responde=STA，那么因变量的取值为1。   </p>
<h6 id="决策树的大小"><a href="#决策树的大小" class="headerlink" title="决策树的大小"></a>决策树的大小</h6><p>minbucket可以理解为，决策树被节点分割后，每个bucket数据的数量。<br>minbucket越大，分组越少，split越少。<br>minbucket越小，分组越多，split越多。   </p>
<h6 id="Classification-tree-和-Regression-tree"><a href="#Classification-tree-和-Regression-tree" class="headerlink" title="Classification tree 和 Regression tree"></a>Classification tree 和 Regression tree</h6><ul>
<li>Classification tree analysis is when the predicted outcome is the class to which the data belongs.（简单的讲，预测值是0和1，比如支持还是反对）</li>
<li>Regression tree analysis is when the predicted outcome can be considered a real number.（简单的讲，预测值是可变的，比如房价等等）</li>
</ul>
<p>体现在代码中的话，<br>如果指定了type = “class”，那么是 Classification tree。<br>如果没有指定type = “class”，那么是 Regression tree。   </p>
<h4 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h4><p>随机森林，被设计出来用于提高CART的精度。<br>和字面意思类似，如果决策树只有一棵树，那么随机森林会创建多个决策树，然后找到效果最好的那一个。<br>那么它是如何创建多个决策树的呢，有点复杂。<br>它并不是多次调用rpart()，简单的调整几个参数而已。<br>每个决策树所用的数据，都只是原数据的随机subset或者说随机子集。<br>如果训练集被分成1，2，3，4，5 这五个子集，那么第一次可能选取2，4，5，2，1，第二次可能选取3，5，1，5，2。</p>
<p>参数nodesize</p>
<pre><code>类似于minbucket，每个子集的最小数目。它越小，生成的决策树越大。
</code></pre><p>参数ntree</p>
<pre><code>生成多少个决策树。一般几百个就够了。
</code></pre><p>好消息是，参数的选取，相比CART而言，对结果的影响没有那么大。</p>
<h4 id="Cross-Validation"><a href="#Cross-Validation" class="headerlink" title="Cross Validation"></a>Cross Validation</h4><p>minbucket应该选取什么样的值，来大道最好效果呢？<br>我们采用 k-fold cross validation 的方法。</p>
<p>我们将训练集train分成k份，比如 k=5 的时候，<br>我们先用1，2，3，4来训练，5用来验证；<br>再用1，2，3，5来训练，4用来验证；<br>再用1，2，4，5来训练，3用来验证。。。<br>所以模型中创建了很多决策树。<br>我们测试每个分割方法下，参数每一个可能的取值，计算这个取值对应的预测精度，绘制曲线。<br>曲线的X轴是参数的取值，Y轴是预测精度，这样可以很容易找到参数的最佳取值。</p>
<h6 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h6><p>像R平方一样，我们也定义了一个概念 cp(complexity parameter) 用来观测效果。<br>cp越小，决策树越大(over fitting)。     </p>
<p><img src="http://latex.codecogs.com/svg.latex?s = splits" alt="formula"><br><img src="http://latex.codecogs.com/svg.latex?\lambda = penalty\\;error" alt="formula"><br><img src="http://latex.codecogs.com/svg.latex?\\sum_{leaves}\(RSS\\;at\\;each\\;leaf\" alt="formula"> + \lambda*s )<br><img src="http://latex.codecogs.com/svg.latex?cp = \\frac{\lambda}{RSS\(no\\;splits\" alt="formula">})<br>cp越大，分母越小，tree越小。<br>cp越小，分母越大，tree越大。</p>
<h3 id="2-建模和评估"><a href="#2-建模和评估" class="headerlink" title="2.建模和评估"></a>2.建模和评估</h3><h4 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h4><pre><code># Install rpart library
install.packages(&quot;rpart&quot;)
library(rpart)
install.packages(&quot;rpart.plot&quot;)
library(rpart.plot)

# CART model
# method=&quot;class&quot; 表示我们创建了一个 classification tree
StevensTree = rpart(Reverse ~ Circuit + Issue + Petitioner + Respondent + LowerCourt + Unconst, data = Train, method=&quot;class&quot;, minbucket=25)

# plot tree
prp(StevensTree)

# Make predictions
# 记得指定 type = &quot;class&quot;
PredictCART = predict(StevensTree, newdata = Test, type = &quot;class&quot;)
table(Test$Reverse, PredictCART)

# ROC curve
library(ROCR)

PredictROC = predict(StevensTree, newdata = Test)
# 注意这里没有指定 type = &quot;class&quot;
# 也就是说，学习得到 classification tree 的模型，但是评估使用 regression tree
# 真是天杀的。。。
# 这个PredictROC 有两列
# 第一列是预测y=0的概率
# 第二列是预测y=1的概率
# 如果比较一下 PredictROC 每行的数据，可以发现这两个概率和为1！那是当然！
# 如果拿 PredictROC 和 PredictCART相比
# 如果 PredictROC[n,2]&gt;0.5，那么PredictCART[n]=1。
# 如果 PredictROC[n,2]&lt;0.5，那么PredictCART[n]=0。
# 所以下面我们只使用第二列

pred = prediction(PredictROC[,2], Test$Reverse)
perf = performance(pred, &quot;tpr&quot;, &quot;fpr&quot;)
plot(perf)

# AUC
as.numeric(performance(pred, &quot;auc&quot;)@y.values)
</code></pre><h4 id="Random-Forest-1"><a href="#Random-Forest-1" class="headerlink" title="Random Forest"></a>Random Forest</h4><pre><code>install.packages(&quot;randomForest&quot;)
library(randomForest)

# Build random forest model
StevensForest = randomForest(Reverse ~ Circuit + Issue + Petitioner + Respondent + LowerCourt + Unconst, data = Train, ntree=200, nodesize=25 )
# Warning message:
# In randomForest.default(m, y, ...) :
#   The response has five or fewer unique values.  Are you sure you want to do regression?

# 如上面的提示消息所示
# randomForest认为因变量的取值很少，不应该用regression
# 但是 random forest 没有 type = &quot;class&quot; 这样的参数
# 所以我们必须确保因变量这一列的取值都是因子
# Convert outcome to factor
Train$Reverse = as.factor(Train$Reverse)
Test$Reverse = as.factor(Test$Reverse)

# Try again
StevensForest = randomForest(Reverse ~ Circuit + Issue + Petitioner + Respondent + LowerCourt + Unconst, data = Train, ntree=200, nodesize=25 )

# Make predictions
PredictForest = predict(StevensForest, newdata = Test)
table(Test$Reverse, PredictForest)
</code></pre><h4 id="Cross-Validation-1"><a href="#Cross-Validation-1" class="headerlink" title="Cross Validation"></a>Cross Validation</h4><pre><code># Install cross-validation packages
install.packages(&quot;caret&quot;)
library(caret)
install.packages(&quot;e1071&quot;)
library(e1071)

# Define cross-validation experiment
numFolds = trainControl( method = &quot;cv&quot;, number = 10 )
cpGrid = expand.grid( .cp = seq(0.01,0.5,0.01)) 

# Perform the cross validation
train(Reverse ~ Circuit + Issue + Petitioner + Respondent + LowerCourt + Unconst, data = Train, method = &quot;rpart&quot;, trControl = numFolds, tuneGrid = cpGrid )

# Create a new CART model
StevensTreeCV = rpart(Reverse ~ Circuit + Issue + Petitioner + Respondent + LowerCourt + Unconst, data = Train, method=&quot;class&quot;, cp = 0.18)

# Make predictions
PredictCV = predict(StevensTreeCV, newdata = Test, type = &quot;class&quot;)
table(Test$Reverse, PredictCV)
</code></pre><h4 id="参数cp和loss的使用"><a href="#参数cp和loss的使用" class="headerlink" title="参数cp和loss的使用"></a>参数cp和loss的使用</h4><pre><code># Penalty Matrix
PenaltyMatrix = matrix(c(0,1,2,3,4,2,0,1,2,3,4,2,0,1,2,6,4,2,0,1,8,6,4,2,0), byrow=TRUE, nrow=5)

# CART model
ClaimsTree = rpart(bucket2009 ~ age + alzheimers + arthritis + cancer + copd + depression + diabetes + heart.failure + ihd + kidney + osteoporosis + stroke + bucket2008 + reimbursement2008, data=ClaimsTrain, method=&quot;class&quot;, cp=0.00005)

prp(ClaimsTree)

# Make predictions
PredictTest = predict(ClaimsTree, newdata = ClaimsTest, type = &quot;class&quot;)
# New CART model with loss matrix
ClaimsTree = rpart(bucket2009 ~ age + alzheimers + arthritis + cancer + copd + depression + diabetes + heart.failure + ihd + kidney + osteoporosis + stroke + bucket2008 + reimbursement2008, data=ClaimsTrain, method=&quot;class&quot;, cp=0.00005, parms=list(loss=PenaltyMatrix))

# Redo predictions and penalty error
PredictTest = predict(ClaimsTree, newdata = ClaimsTest, type = &quot;class&quot;)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/10/2016/2016-05-10-R04/" data-id="cj8lnyu1u0000xuw82wi556dc" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-04-26-R03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/2016/2016-04-26-R03/" class="article-date">
  <time datetime="2016-04-25T19:52:13.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据分析笔记/">数据分析笔记</a>►<a class="article-category-link" href="/categories/数据分析笔记/新知/">新知</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/2016/2016-04-26-R03/">MIT:The Analytics Edge 笔记03－指数回归</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MIT课程 <a href="https://courses.edx.org/courses/course-v1:MITx+15.071x_3+1T2016/info" target="_blank" rel="external">15.071x The Analytics Edge</a> 第三单元的学习记录。</p>
<hr>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><p>第三单元的主题是指数回归。</p>
<h3 id="1-理论"><a href="#1-理论" class="headerlink" title="1.理论"></a>1.理论</h3><h4 id="指数回归"><a href="#指数回归" class="headerlink" title="指数回归"></a>指数回归</h4><p>指数回归用于因变量y是二进制的情况，也就是说，y的取值只有1或者0。<br>y=1的概率：<br><img src="http://latex.codecogs.com/svg.latex?P\(y=1\" alt="formula">=\frac{1}{1+e^{-{(\beta_0 +\beta_1x_1+\beta_2x_2+\ldots+\beta_nx_n+\epsilon)}}})  </p>
<p>y=1的概率与y＝0的概率的比值：<br><img src="http://latex.codecogs.com/svg.latex?Odds=\\frac{P\(y=1\" alt="formula">}{P(y=0)})   </p>
<p><img src="http://latex.codecogs.com/svg.latex?Odds=\\frac{P\(y=1\" alt="formula">}{1-P(y=1)})   </p>
<p><img src="http://latex.codecogs.com/svg.latex?Odds=e^{\\beta_0 +\\beta_1x_1+\\beta_2x_2+\\ldots+\\beta_nx_n+\\epsilon}" alt="formula">   </p>
<h4 id="混淆矩阵（confusion-matrix）"><a href="#混淆矩阵（confusion-matrix）" class="headerlink" title="混淆矩阵（confusion matrix）"></a>混淆矩阵（confusion matrix）</h4><p>有阈值t，<br>如果P(y=1) &gt;=t，则预测y=1。<br>如果P(y=1) &lt; t，则预测y=0。   </p>
<p>对于预测结果，我们得到矩阵   </p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">predict y=0</th>
<th style="text-align:left">predict y=1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">actual y=0</td>
<td style="text-align:left">TN (True  Nagative)</td>
<td style="text-align:left">FP (False Positive)</td>
</tr>
<tr>
<td style="text-align:left">actual y=1</td>
<td style="text-align:left">FN (False Nagative)</td>
<td style="text-align:left">TP (True  Positive)</td>
</tr>
</tbody>
</table>
<p>根据矩阵中的值，我们可以计算指数回归的一些指标：   </p>
<p><img src="http://latex.codecogs.com/svg.latex?accuracy=\\frac{TN+TP}{N}" alt="formula"><br><img src="http://latex.codecogs.com/svg.latex?specificity=\\frac{TN}{TN+FP}" alt="formula"><br><img src="http://latex.codecogs.com/svg.latex?sensitivity=\\frac{TP}{FN+TP}" alt="formula">   </p>
<p>补充概念：<br>适合率<br><img src="http://latex.codecogs.com/svg.latex?precision=\\frac{TP}{FP+TP}" alt="formula"><br>再现率<br><img src="http://latex.codecogs.com/svg.latex?recall=tpr=\\frac{TP}{FN+TP}" alt="formula"><br>F值（F-measure）<br><img src="http://latex.codecogs.com/svg.latex?F-measure=\\frac{2*precision*recall}{precision+recall}" alt="formula"><br>F值越高，性能越好</p>
<h4 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h4><p>ROC曲线 (Receiver Operator Characteristic curve)可以指导我们如何选取阈值t。<br>y轴的指标是 sensitivity，所以也叫 True positive rate。   </p>
<p><img src="http://latex.codecogs.com/svg.latex?sensitivity=\\frac{TP}{FN+TP}" alt="formula"><br>x轴的指标是 1-specificity，所以也叫 False positive rate。   </p>
<p><img src="http://latex.codecogs.com/svg.latex?1-sensitivity=\\frac{FP}{TN+FP}" alt="formula">    </p>
<p>每取一个阈值t，则计算相对应的 TPR 和 FPR，在坐标里标出这个点，就形成ROC曲线。<br><img src="http://7xrjai.com1.z0.glb.clouddn.com/20160509-ROC.png" alt="ROC Curve">   </p>
<p>如图所示，   </p>
<pre><code>t=0时，我们预测所有的y=1，即TPR=1，FPR=1，对应的坐标是(1,1)   
t=1时，我们预测所有的y=0，即TPR=0，FPR=0，对应的坐标是(0,0)   
</code></pre><p>这就是曲线的两个端点。</p>
<h4 id="AUC值"><a href="#AUC值" class="headerlink" title="AUC值"></a>AUC值</h4><p>AUC（Area Under Curve）被定义为ROC曲线下的面积，显然这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围在0.5和1之间。   </p>
<h3 id="2-建立回归模型"><a href="#2-建立回归模型" class="headerlink" title="2.建立回归模型"></a>2.建立回归模型</h3><pre><code># 建立模型
# Top10作为因变量，其他所有的列都作为自变量
SongsLog1 = glm(Top10 ~ ., data=SongsTrain, family=binomial)

# Top10作为因变量，除了loudness以外的所有列都作为自变量
SongsLog2 = glm(Top10 ~ . - loudness, data=SongsTrain, family=binomial)
</code></pre><h3 id="3-评估"><a href="#3-评估" class="headerlink" title="3.评估"></a>3.评估</h3><pre><code># 预测
testPredict = predict(SongsLog3, newdata=SongsTest, type=&quot;response&quot;)

# 生成混淆矩阵
table(SongsTest$Top10, testPredict &gt;= 0.45)

# 生成ROC曲线
library(ROCR)
pred = prediction(testPredict, test$violator)
perf = performance(pred, &quot;tpr&quot;, &quot;fpr&quot;)
plot(perf)

# 加点颜色和坐标点
plot(perf, colorize=TRUE, print.cutoffs.at=seq(0,1,0.1), text.adj=c(-0.2,1.7))

# 计算AUC值
as.numeric(performance(pred, &quot;auc&quot;)@y.values)
</code></pre><h3 id="附录A-分割train和test的方法一"><a href="#附录A-分割train和test的方法一" class="headerlink" title="附录A 分割train和test的方法一"></a>附录A 分割train和test的方法一</h3><pre><code>library(caTools)
set.seed(144)

split = sample.split(parole$violator, SplitRatio = 0.7)
train = subset(parole, split == TRUE)
test = subset(parole, split == FALSE)
# 特别注意：每次运行出来的结果是不一样的
</code></pre><p>也可以这样做：</p>
<pre><code>library(caTools)
set.seed(144)

split = sample(1:nrow(data), size=0.7 * nrow(data))
train = data[split,]
test = data[-split,]
</code></pre><h3 id="附录B-补充缺失数据"><a href="#附录B-补充缺失数据" class="headerlink" title="附录B 补充缺失数据"></a>附录B 补充缺失数据</h3><pre><code>library(mice)
set.seed(144)
vars.for.imputation = setdiff(names(loans), &quot;not.fully.paid&quot;)
imputed = complete(mice(loans[vars.for.imputation]))
loans[vars.for.imputation] = imputed
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/26/2016/2016-04-26-R03/" data-id="cj8lnyg8c000jxtw8k28ezmal" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-04-23-R02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/23/2016/2016-04-23-R02/" class="article-date">
  <time datetime="2016-04-22T23:19:39.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据分析笔记/">数据分析笔记</a>►<a class="article-category-link" href="/categories/数据分析笔记/新知/">新知</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/2016/2016-04-23-R02/">MIT:The Analytics Edge 笔记02－线性回归</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MIT课程 <a href="https://courses.edx.org/courses/course-v1:MITx+15.071x_3+1T2016/info" target="_blank" rel="external">15.071x The Analytics Edge</a> 第二单元的学习记录。</p>
<hr>
<h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><p>第二单元的主题是线性回归。</p>
<h3 id="1-理论"><a href="#1-理论" class="headerlink" title="1.理论"></a>1.理论</h3><p>一元线性回归公式：   </p>
<p><img src="http://latex.codecogs.com/svg.latex?y^i=\\beta_0+\\beta_1x^i+\\epsilon^i" alt="formula">   </p>
<p>其中x是自变量independent variable，y是因变量dependent variable。<br>beta是相关系数coefficient，epsilon是误差error。   </p>
<p>为了判断线性回归的效果，我们有如下检验标准：   </p>
<p>1.SSE（sum of squared errors）<br>注意这里的误差是实际值相对于预测值的。   </p>
<p><img src="http://latex.codecogs.com/svg.latex?SSE = \\sum_{i=1}^{n}\\epsilon_i^2" alt="formula">   </p>
<p>2.SST （total sum of square）<br>公式同上。但这里的误差是实际值相对于baseline的。baseline是因变量的平均值。<br>所以有 0 &lt;= SSE &lt;= SST 。 </p>
<p>3.RMSE（root mean square error）   </p>
<p><img src="http://latex.codecogs.com/svg.latex?RMSE = \\sqrt\\frac{SSE}{n}" alt="formula">   </p>
<p>4.R平方   </p>
<p><img src="http://latex.codecogs.com/svg.latex?R^2 = 1 - \\frac{SSE}{SST}" alt="formula">   </p>
<p>R平方越接近1越好。   </p>
<p>多元线性回归公式：   </p>
<p><img src="http://latex.codecogs.com/svg.latex?y^i = \\beta_0 + \\beta_1x_1^i + \\beta_2x_2^i + \\ldots + \\beta_nx_n^i + \\epsilon^i" alt="formula">   </p>
<pre><code>所有数据分析，都要经历 training－test－predict 这三个过程。
在接下来的例子中，我们介绍 建模－评估 这前两个过程。
</code></pre><p>补充一个relative error的公式：   </p>
<p><img src="http://latex.codecogs.com/svg.latex?relative\\;error =  \\frac{observed\\;value - estimated\\,value}{observed\\;value}" alt="formula"></p>
<h5 id="2-0-事前整理"><a href="#2-0-事前整理" class="headerlink" title="2.0 事前整理"></a>2.0 事前整理</h5><p>2.0.1 去除空值</p>
<pre><code># 如果数据中包含空值
DF ＝ na.omit(DF)
</code></pre><p>2.0.2 reference level<br>有些列时字符型的，它们无法进行计算。<br>如果某列的因子不算多，我们可以把这一列变换成多个可以用于计算的列。   </p>
<pre><code># 假设DF$colr有因子 &quot;Red&quot;4次, &quot;Blue&quot;3次, &quot;Yellow&quot;2次
DF$colr = relevel(DF$colr, &quot;red&quot;)

# 效果是，DF$colr 这一列不见了
# 增加了两列 DF$colrBlue 和 DF$colrYellow
# 原先 DF$colr == &quot;Red&quot; 的那些行，它们 colrBlue 和 colrYellow 的值都是0
# 原先 DF$colr == &quot;Blue&quot; 的那些行，它们 colrBlue=1, colrYellow=0
# 原先 DF$colr == &quot;Yellow&quot; 的那些行，它们 colrBlue=0, colrYellow=1
</code></pre><h3 id="2-建立回归模型"><a href="#2-建立回归模型" class="headerlink" title="2.建立回归模型"></a>2.建立回归模型</h3><p>建模使用lm()函数。<br>DF是保存学习数据的data.frame。</p>
<pre><code>model = lm(y ~ x1 + x2 + ... +xn, data = DF)
# y不要写成 DF$y
# x1也不要写成 DF$x1
# 否则，后面做预测predict()的时候，DFTest代入会报warning

# 除了y列以外所有列
model = lm(y ~ ., data = DF)

# 误差 model$residuals
SSE = sum(model$residuals^2)
</code></pre><p>随便看个结果吧</p>
<pre><code>&gt; summary(model)

Call:
lm(formula = Price ~ HarvestRain + WinterRain, data = wine)

Residuals:
    Min      1Q  Median      3Q     Max 
-1.0933 -0.3222 -0.1012  0.3871  1.1877 

Coefficients:
              Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  7.865e+00  6.616e-01  11.888 4.76e-11 ***
HarvestRain -4.971e-03  1.601e-03  -3.105  0.00516 ** 
WinterRain  -9.848e-05  9.007e-04  -0.109  0.91392    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.5611 on 22 degrees of freedom
Multiple R-squared:  0.3177,    Adjusted R-squared:  0.2557 
F-statistic: 5.122 on 2 and 22 DF,  p-value: 0.01492
</code></pre><p>Call表示建模使用的语句。<br>Residuals表示误差。<br>Coefficients表示系数，就是公式里面的beta。<br>Estimate的第一行是常数beta0，第二行是第一个自变量的系数beta1，第三行是第二个自变量的系数beta2，后面类推。<br>t value越大越好</p>
<p><img src="http://latex.codecogs.com/svg.latex?{t\\,value} = \\frac{Estimate}{Std. Error}" alt="formula">   </p>
<p>Pr(&gt;|t|) 和t value相反，越小越好。<br>最后一列星星越多越好。<br>三短横下面这行解释了星星的含义。<br>Multiple R-squared就是R平方，越接近1越准确。</p>
<h3 id="3-评估"><a href="#3-评估" class="headerlink" title="3.评估"></a>3.评估</h3><p>对于刚过简历的模型，我们使用测试数据来评估一下准确度。<br>model就是上文建立的模型。<br>DFTest是测试数据，它的结构和上文的DF一样。   </p>
<pre><code>predict = predict(model, newdata = DFTest)
</code></pre><p>这个命令的返回值是 DFTest$Price 的<strong>预测</strong>结果。你可以跟 DFTest$Price 的<strong>实际</strong>结果相比较，计算SSE、RMSE、R平方等等来衡量对测试数据的预测的准确性。   </p>
<pre><code>SSE = sum( (DFTest$Price - predict)^2 )
SST = sum( (DFTest$Price - mean(DF$Price)^2 )
R2 = 1 - SSE/SST
</code></pre><h3 id="4-Correlation"><a href="#4-Correlation" class="headerlink" title="4.Correlation"></a>4.Correlation</h3><p>线性相关性</p>
<pre><code>cor(var1, var2)
# 也可以考察整个DF中，每两列的线性相关性
cor(DF)
</code></pre><p>返回值是斜率。   </p>
<p><strong>建立线性回归模型的时候，应该去掉相关性比较高的列。</strong></p>
<h3 id="补充知识A－棒球统计术语"><a href="#补充知识A－棒球统计术语" class="headerlink" title="补充知识A－棒球统计术语"></a>补充知识A－棒球统计术语</h3><p>完全不懂棒球啊，一开始摸不着头脑。</p>
<table>
<thead>
<tr>
<th style="text-align:left">缩写</th>
<th style="text-align:left">原文</th>
<th style="text-align:left">中文</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">RS</td>
<td style="text-align:left">Run Scores</td>
<td style="text-align:left">跑分，得分</td>
</tr>
<tr>
<td style="text-align:left">RA</td>
<td style="text-align:left">Run Allowed</td>
<td style="text-align:left">失分，对手得分</td>
</tr>
<tr>
<td style="text-align:left">OBP</td>
<td style="text-align:left">On-Base Percentage</td>
<td style="text-align:left">上垒率</td>
</tr>
<tr>
<td style="text-align:left">OOBP</td>
<td style="text-align:left">Opponent On-Base Percentage</td>
<td style="text-align:left">对手上垒率</td>
</tr>
<tr>
<td style="text-align:left">SLG</td>
<td style="text-align:left">Slugging Percentage</td>
<td style="text-align:left">长打率，击中率</td>
</tr>
<tr>
<td style="text-align:left">OSLG</td>
<td style="text-align:left">Opponent Slugging Percentage</td>
<td style="text-align:left">对手长打率</td>
</tr>
<tr>
<td style="text-align:left">BA</td>
<td style="text-align:left">Batting Avarage</td>
<td style="text-align:left">平均成功率</td>
</tr>
</tbody>
</table>
<h3 id="补充知识B－篮球统计术语"><a href="#补充知识B－篮球统计术语" class="headerlink" title="补充知识B－篮球统计术语"></a>补充知识B－篮球统计术语</h3><p>年轻时看NBA，好歹知道一点。</p>
<table>
<thead>
<tr>
<th style="text-align:left">缩写</th>
<th style="text-align:left">原文</th>
<th style="text-align:left">中文</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PTS</td>
<td style="text-align:left">Points</td>
<td style="text-align:left">得分</td>
</tr>
<tr>
<td style="text-align:left">oppPTS</td>
<td style="text-align:left">Opponent Points</td>
<td style="text-align:left">失分，对手得分</td>
</tr>
<tr>
<td style="text-align:left">FG</td>
<td style="text-align:left">Field Goals (success)</td>
<td style="text-align:left">进球数</td>
</tr>
<tr>
<td style="text-align:left">FGA</td>
<td style="text-align:left">Field Goals Attempted</td>
<td style="text-align:left">出手次数</td>
</tr>
<tr>
<td style="text-align:left">X2P</td>
<td style="text-align:left">2 Points</td>
<td style="text-align:left">2分球进球数</td>
</tr>
<tr>
<td style="text-align:left">X2PA</td>
<td style="text-align:left">2 Points Attempted</td>
<td style="text-align:left">2分球出手次数</td>
</tr>
<tr>
<td style="text-align:left">X3P</td>
<td style="text-align:left">3 Points</td>
<td style="text-align:left">3分球进球数</td>
</tr>
<tr>
<td style="text-align:left">X3PA</td>
<td style="text-align:left">3 Points Attempted</td>
<td style="text-align:left">3分球出手次数</td>
</tr>
<tr>
<td style="text-align:left">FT</td>
<td style="text-align:left">Free Throw</td>
<td style="text-align:left">罚球进球数</td>
</tr>
<tr>
<td style="text-align:left">FTA</td>
<td style="text-align:left">Free Throw Attempted</td>
<td style="text-align:left">发球出手次数</td>
</tr>
<tr>
<td style="text-align:left">ORB</td>
<td style="text-align:left">Offensive Rebounds</td>
<td style="text-align:left">前场篮板，进攻篮板</td>
</tr>
<tr>
<td style="text-align:left">DRB</td>
<td style="text-align:left">Defensive Rebounds</td>
<td style="text-align:left">后场篮板，防守篮板</td>
</tr>
<tr>
<td style="text-align:left">AST</td>
<td style="text-align:left">Assists</td>
<td style="text-align:left">助攻</td>
</tr>
<tr>
<td style="text-align:left">STL</td>
<td style="text-align:left">Steals</td>
<td style="text-align:left">抢断</td>
</tr>
<tr>
<td style="text-align:left">BLK</td>
<td style="text-align:left">Blocks</td>
<td style="text-align:left">盖帽</td>
</tr>
<tr>
<td style="text-align:left">TOV</td>
<td style="text-align:left">Turnovers</td>
<td style="text-align:left">失误</td>
</tr>
</tbody>
</table>
<p>注：X2P列，原始数据列名是2P。由于R不支持数字开头的列名／变量，读取CSV文件的时候，会在原列名2P前加个X，从而变成 X2P。</p>
<h3 id="补充知识C－滞后序列"><a href="#补充知识C－滞后序列" class="headerlink" title="补充知识C－滞后序列"></a>补充知识C－滞后序列</h3><p>函数lag，用于生成滞后/偏移序列？   </p>
<pre><code>lag(x, k = 1, ...)
# k &lt; 0, previous observations   
# k &gt; 0, future observations
# na.pad=TRUE, add missing values
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/23/2016/2016-04-23-R02/" data-id="cj8lnyg8a000hxtw8bs0y53mq" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-04-18-R01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/2016/2016-04-18-R01/" class="article-date">
  <time datetime="2016-04-18T03:55:25.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据分析笔记/">数据分析笔记</a>►<a class="article-category-link" href="/categories/数据分析笔记/新知/">新知</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/2016/2016-04-18-R01/">MIT:The Analytics Edge 笔记01－R语言入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MIT课程 <a href="https://courses.edx.org/courses/course-v1:MITx+15.071x_3+1T2016/info" target="_blank" rel="external">15.071x The Analytics Edge</a> 第一单元的学习记录。</p>
<hr>
<h2 id="R语言入门"><a href="#R语言入门" class="headerlink" title="R语言入门"></a>R语言入门</h2><p>R语言入门只讲了一些常用的操作。相对于动辄花一本书来讲这些，真是相当简约。但其实足够了，其他操作，需要的时候再查嘛。<br>数据分析的四要素：data、models、decisions、value    </p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>帮助：</p>
<pre><code>?func
</code></pre><p>显示当前的临时变量：</p>
<pre><code>ls()
</code></pre><p>获取／设置当前目录：</p>
<pre><code>getwd()
setwd()
</code></pre><p>显示当前文件夹下的文件：</p>
<pre><code>dir()
</code></pre><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>向量概念：</p>
<pre><code>所有的操作都是对向量的每个元素实施的
</code></pre><p>data.frame：</p>
<pre><code>observation：行
variable   ：列，data.frame是按照列存储的
rbind()合并两个data.frame
</code></pre><p>序列：</p>
<pre><code>自动生成序列seq()
</code></pre><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>读取CSV文件：</p>
<pre><code>DF = read.csv(&quot;file_path&quot;)
# 返回值是data.frame
</code></pre><p>查看DF的基本信息：</p>
<pre><code>str(DF)
# DF的结构信息。行和列的数目，列名、列的类型、列的数据举例。

summary(DF)
# 每列的最大值、最小值、中位数、平均数、1/4值、3/4值，以及是否包含空值。
</code></pre><p>写入CSV文件：</p>
<pre><code>write.csv(DF, &quot;file_path&quot;)
</code></pre><p>从内存中删除变量：</p>
<pre><code>rm(DF)
</code></pre><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><p>选取一部分数据：</p>
<pre><code>subset( DF, 条件1 &amp; 条件2 ｜ 条件3)
</code></pre><p>按照列名选取3列：</p>
<pre><code>DF[c(var1, var2, var3)]
</code></pre><p>选取1，3，5列：</p>
<pre><code>DF[c(1, 3, 5)]
</code></pre><p>计算平均值和标准差：</p>
<pre><code>mean(DF$var)
sd(DF$var)
</code></pre><p>返回最大值／最小值的位置(index)：</p>
<pre><code>which.max(DF$var)
which.min(DF$var)
</code></pre><p>返回行数：</p>
<pre><code>nrow(DF)
</code></pre><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>直方图，反映<strong>一列</strong>数据的分布情况：</p>
<pre><code>hist(DF$var, xlim = c(1, 100), breaks = 100)
# xlim 限定范围
# breaks x轴的精确度。注意是针对原始数据的，不是对限定后的
</code></pre><p>箱型图：</p>
<pre><code>boxplot(DF$var1 ~ DF$var2, xlab = &quot;x-label&quot;, ylab = &quot;y-label&quot;, main = &quot;title&quot;)
</code></pre><p>点阵图：</p>
<pre><code>plot(......, col = &quot;red&quot;)
line(......, col = &quot;blue&quot;) # 在原先的基础上再加一条

函数jitter() # 对于有很多重合的点阵图，先用jitter偏移一点，这样看上去效果好很多
</code></pre><p>其他共通的参数：</p>
<pre><code>col = &quot;red&quot;
type = &quot;line&quot; # 可以指定1，2，3，4，5
</code></pre><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>分组：</p>
<pre><code>table(DF$var1)
# var1列中，每种数据的数量的统计
table(DF$var1, DF$var2)
# var1和var2列中，每种数据的数量的交叉统计
</code></pre><p>分组计算：</p>
<pre><code>tapply(DF$var1, DF$var2, func)
# DF$var1, 原始数据
# DF$var2, 分组依据
# func, 要应用的函数
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/2016/2016-04-18-R01/" data-id="cj8lnyg87000fxtw8vngnqg2y" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-04-08-datatable5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/08/2016/2016-04-08-datatable5/" class="article-date">
  <time datetime="2016-04-07T21:00:57.000Z" itemprop="datePublished">2016-04-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/新知/">新知</a>►<a class="article-category-link" href="/categories/新知/data-table教程/">data.table教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/08/2016/2016-04-08-datatable5/">data.table 教程5－数据拆分和合并</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目录：   </p>
<ol>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-13-datatable1/" target="_blank" rel="external">data.table 介绍</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-21-datatable2/" target="_blank" rel="external">语义引用</a>      </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-22-datatable3/" target="_blank" rel="external">主键、基于二分法搜索的subset</a>    </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-02-datatable4/" target="_blank" rel="external">二次索引和自动索引</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-08-datatable5/" target="_blank" rel="external">数据拆分和合并</a>   </li>
</ol>
<p>原文地址：<br><a href="https://github.com/Rdatatable/data.table/wiki/Getting-started" target="_blank" rel="external">data.table/wiki/Getting-started</a></p>
<hr>
<h1 id="数据拆分和合并"><a href="#数据拆分和合并" class="headerlink" title="数据拆分和合并"></a>数据拆分和合并</h1><p>这一讲我们学习reshaping函数 melt 和 dcast 原本的用法，以及从R语言 v1.9.6版以后，函数 melt 和 dcast 新扩展的功能（它们能操作多个列）。   </p>
<hr>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>我们在讲解的时候直接加载数据。   </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>data.table的函数melt 和 dcast 是增强包<a href="https://cran.r-project.org/web/packages/reshape2/index.html" target="_blank" rel="external">reshape2</a>里同名函数的扩展。<br>在这一讲，我们会：   </p>
<ul>
<li>首先，简单看一下原先的函数 melt 和 dcast，它们是如何reshaping一个data.table。  </li>
<li>然后，了解一下当前的功能是如何变得冗长而且低效。   </li>
<li>最后，学习一下改进之后的函数 melt 和 dcast 如何同时处理多个列。   </li>
</ul>
<p>扩展后的功能符合data.table的设计哲学：运行高效，语法简明。   </p>
<p>注意：</p>
<pre><code>从R语言 v1.9.6版以后，你再也不需要加载增强包 reshape2 了，只需要加载 data.table。如果你已经加载了 reshape2 来处理矩阵或者data.frame，那么一定要确保在这之后再加载 data.table。
</code></pre><h2 id="1-原生的melt／dcast"><a href="#1-原生的melt／dcast" class="headerlink" title="1.原生的melt／dcast"></a>1.原生的melt／dcast</h2><h4 id="a-函数melt"><a href="#a-函数melt" class="headerlink" title="a) 函数melt"></a>a) 函数melt</h4><p>假设我们有下面这样的data.table：</p>
<pre><code>DT = fread(&quot;melt_default.csv&quot;)
DT
#    family_id age_mother dob_child1 dob_child2 dob_child3
# 1:         1         30 1998-11-26 2000-01-29         NA
# 2:         2         27 1996-06-22         NA         NA
# 3:         3         26 2002-07-11 2004-04-05 2007-09-02
# 4:         4         32 2004-10-10 2009-08-27 2012-07-21
# 5:         5         29 2000-12-05 2005-02-28         NA
## dob stands for date of birth.

str(DT)
# Classes &apos;data.table&apos; and &apos;data.frame&apos;:    5 obs. of  5 variables:
#  $ family_id : int  1 2 3 4 5
#  $ age_mother: int  30 27 26 32 29
#  $ dob_child1: chr  &quot;1998-11-26&quot; &quot;1996-06-22&quot; &quot;2002-07-11&quot; &quot;2004-10-10&quot; ...
#  $ dob_child2: chr  &quot;2000-01-29&quot; NA &quot;2004-04-05&quot; &quot;2009-08-27&quot; ...
#  $ dob_child3: chr  NA NA &quot;2007-09-02&quot; &quot;2012-07-21&quot; ...
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;
</code></pre><p>－转化DT，使得每个小孩的出生信息都独占一条数据<br>我们可以对函数 melt() 指定参数 id.vars 和 measure.vars 来实现   </p>
<pre><code>DT.m1 = melt(DT, id.vars = c(&quot;family_id&quot;, &quot;age_mother&quot;),
        measure.vars = c(&quot;dob_child1&quot;, &quot;dob_child2&quot;, &quot;dob_child3&quot;))
DT.m1
#     family_id age_mother   variable      value
#  1:         1         30 dob_child1 1998-11-26
#  2:         2         27 dob_child1 1996-06-22
#  3:         3         26 dob_child1 2002-07-11
#  4:         4         32 dob_child1 2004-10-10
#  5:         5         29 dob_child1 2000-12-05
#  6:         1         30 dob_child2 2000-01-29
#  7:         2         27 dob_child2         NA
#  8:         3         26 dob_child2 2004-04-05
#  9:         4         32 dob_child2 2009-08-27
# 10:         5         29 dob_child2 2005-02-28
# 11:         1         30 dob_child3         NA
# 12:         2         27 dob_child3         NA
# 13:         3         26 dob_child3 2007-09-02
# 14:         4         32 dob_child3 2012-07-21
# 15:         5         29 dob_child3         NA
str(DT.m1)
# Classes &apos;data.table&apos; and &apos;data.frame&apos;:    15 obs. of  4 variables:
#  $ family_id : int  1 2 3 4 5 1 2 3 4 5 ...
#  $ age_mother: int  30 27 26 32 29 30 27 26 32 29 ...
#  $ variable  : Factor w/ 3 levels &quot;dob_child1&quot;,&quot;dob_child2&quot;,..: 1 1 1 1 1 2 2 2 2 2 ...
#  $ value     : chr  &quot;1998-11-26&quot; &quot;1996-06-22&quot; &quot;2002-07-11&quot; &quot;2004-10-10&quot; ...
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;
</code></pre><p>说明：</p>
<ul>
<li>参数 measure.vars 指定了想要拆分（或合并）的列。</li>
<li>我们也可以指定索引而不是列名。</li>
<li>默认的，variable列是 factor（因子）类型的。如果你想返回一个字符型的向量，可以将参数 variable.factor 设为 FALSE。参数 variable.factor 是data.table的函数melt() 里独有的，增强包reshape2 里面没有这个参数。</li>
<li>默认的，转化果的列被自动命名为 variable 和 value。</li>
<li>在结果里，函数melt() 保持了原来列的属性。</li>
</ul>
<p>－分别将 variable列和 value列重命名为 child 和 dob   </p>
<pre><code>DT.m1 = melt(DT, measure.vars = c(&quot;dob_child1&quot;, &quot;dob_child2&quot;, &quot;dob_child3&quot;),
           variable.name = &quot;child&quot;, value.name = &quot;dob&quot;)
DT.m1
#     family_id age_mother      child        dob
#  1:         1         30 dob_child1 1998-11-26
#  2:         2         27 dob_child1 1996-06-22
#  3:         3         26 dob_child1 2002-07-11
#  4:         4         32 dob_child1 2004-10-10
#  5:         5         29 dob_child1 2000-12-05
#  6:         1         30 dob_child2 2000-01-29
#  7:         2         27 dob_child2         NA
#  8:         3         26 dob_child2 2004-04-05
#  9:         4         32 dob_child2 2009-08-27
# 10:         5         29 dob_child2 2005-02-28
# 11:         1         30 dob_child3         NA
# 12:         2         27 dob_child3         NA
# 13:         3         26 dob_child3 2007-09-02
# 14:         4         32 dob_child3 2012-07-21
# 15:         5         29 dob_child3         NA
</code></pre><p>说明：</p>
<ul>
<li>默认的，参数id.vars 或 measure.vars 中的一个省略了，剩余的列自动被赋值给省略的那个参数。</li>
<li>如果参数id.vars 和 measure.vars 都没有指定，所有不是numberic／integer／logical的列都会被赋值给 id.vars。另外，系统还会输出一条警告消息，提示那些列被认为是 id.vars。</li>
</ul>
<h4 id="b-函数cast"><a href="#b-函数cast" class="headerlink" title="b) 函数cast"></a>b) 函数cast</h4><p>在前面一节，我们知道如何分拆数据。这一节，我们学习相反的操作。<br>－如何将刚刚分拆的 DT.m 还原成 DT<br>也就是，我们想把每个家庭／母亲的所有小孩，都合并到同一行里。我们可以像下面这样使用函数 dcast()。</p>
<pre><code>dcast(DT.m1, family_id + age_mother ~ child, value.var = &quot;dob&quot;)
#    family_id age_mother dob_child1 dob_child2 dob_child3
# 1:         1         30 1998-11-26 2000-01-29         NA
# 2:         2         27 1996-06-22         NA         NA
# 3:         3         26 2002-07-11 2004-04-05 2007-09-02
# 4:         4         32 2004-10-10 2009-08-27 2012-07-21
# 5:         5         29 2000-12-05 2005-02-28         NA
</code></pre><p>说明：</p>
<ul>
<li>函数 dcast() 使用了操作符“~”，左边是作为 id.vars 的列，右边是作为 measure.vars 的列。</li>
<li>参数 value.var 指定了需要被分拆扩张的列。</li>
<li>函数 dcast() 也会在结果中尽量保持原来的属性。</li>
</ul>
<p>－对于 DT.m，如何知道每个家庭有几个小孩<br>可以给函数 dcast() 的参数 fun.aggregate 传递一个函数。当操作符“~”不方便指定列名的时候，这个功能特别有用。   </p>
<pre><code>dcast(DT.m1, family_id ~ ., fun.agg = function(x) sum(!is.na(x)), value.var = &quot;dob&quot;)
#    family_id .
# 1:         1 2
# 2:         2 1
# 3:         3 3
# 4:         4 3
# 5:         5 2
</code></pre><p>输入 ?dcast 可以查看其他参数和例子的说明。   </p>
<h2 id="2-原生的melt／dcast的局限"><a href="#2-原生的melt／dcast的局限" class="headerlink" title="2.原生的melt／dcast的局限"></a>2.原生的melt／dcast的局限</h2><p>到目前为止，我们学习了函数 melt 和 dcast 的功能，它们是基于增强包 reshape2 的。但是因为使用了data.table的内部机制（快速排序，二分法搜索等），所以能有效地对data.table实行。<br>然而，也有一些情况，我们想做的操作无法写得很简洁。比如，考虑下面这个data.table：</p>
<pre><code>DT = fread(&quot;melt_enhanced.csv&quot;)
DT
#    family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
# 1:         1         30 1998-11-26 2000-01-29         NA             1             2            NA
# 2:         2         27 1996-06-22         NA         NA             2            NA            NA
# 3:         3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
# 4:         4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
# 5:         5         29 2000-12-05 2005-02-28         NA             2             1            NA
## 1 = female, 2 = male
</code></pre><p>如果你想用我们到目前为止学过的知识，将每个孩子的 dob 和 gender 合并到一行中，得这样做：</p>
<pre><code>DT.m1 = melt(DT, id = c(&quot;family_id&quot;, &quot;age_mother&quot;))
# Warning in melt.data.table(DT, id = c(&quot;family_id&quot;, &quot;age_mother&quot;)): &apos;measure.vars&apos; [dob_child1,
# dob_child2, dob_child3, gender_child1, gender_child2, gender_child3] are not all of the same
# type. By order of hierarchy, the molten data value column will be of type &apos;character&apos;. All measure
# variables not of type &apos;character&apos; will be coerced to. Check DETAILS in ?melt.data.table for more on
# coercion.
DT.m1[, c(&quot;variable&quot;, &quot;child&quot;) := tstrsplit(variable, &quot;_&quot;, fixed = TRUE)]
DT.c1 = dcast(DT.m1, family_id + age_mother + child ~ variable, value.var = &quot;value&quot;)
DT.c1
#     family_id age_mother  child        dob gender
#  1:         1         30 child1 1998-11-26      1
#  2:         1         30 child2 2000-01-29      2
#  3:         1         30 child3         NA     NA
#  4:         2         27 child1 1996-06-22      2
#  5:         2         27 child2         NA     NA
#  6:         2         27 child3         NA     NA
#  7:         3         26 child1 2002-07-11      2
#  8:         3         26 child2 2004-04-05      2
#  9:         3         26 child3 2007-09-02      1
# 10:         4         32 child1 2004-10-10      1
# 11:         4         32 child2 2009-08-27      1
# 12:         4         32 child3 2012-07-21      1
# 13:         5         29 child1 2000-12-05      2
# 14:         5         29 child2 2005-02-28      1
# 15:         5         29 child3         NA     NA

str(DT.c1) ## gender column is character type now!
# Classes &apos;data.table&apos; and &apos;data.frame&apos;:    15 obs. of  5 variables:
#  $ family_id : int  1 1 1 2 2 2 3 3 3 4 ...
#  $ age_mother: int  30 30 30 27 27 27 26 26 26 32 ...
#  $ child     : chr  &quot;child1&quot; &quot;child2&quot; &quot;child3&quot; &quot;child1&quot; ...
#  $ dob       : chr  &quot;1998-11-26&quot; &quot;2000-01-29&quot; NA &quot;1996-06-22&quot; ...
#  $ gender    : chr  &quot;1&quot; &quot;2&quot; NA &quot;2&quot; ...
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 
#  - attr(*, &quot;sorted&quot;)= chr  &quot;family_id&quot; &quot;age_mother&quot; &quot;child&quot;
</code></pre><p>问题：</p>
<ol>
<li>我们想做的是，分别将每个孩子的 dob 和 gender 合并到一行。但是我们先把所有的东西都拆分开了，再将它们合并。很容易看出，这太过迂回和低效了。<br>类似的，想想你的壁橱里有4架子的衣服，你想把第1架和第2架的衣服全都放到第1架上，把第3架和第4架的衣服全都放到第3架上。我们刚刚做的事情，就像把4架衣服都放一起，再分开放到第1架和第3架上！</li>
<li>需要被整合的列可能是不同的类型，在这个例子里面，是字符型和整型。使用函数melt 的时候，这些列被硬塞到结果里面，正如str(DT.c1)的警告消息所提示的，gender列被转化成了字符型。</li>
<li>我们将variable拆分成了两列，因此额外多了一列，这样做的目的真是非常模糊。我们这么做是因为下一步我们需要转化这一列。</li>
<li>最后，我们整合了数据。但是问题是我们引入很多操作。特别是，必须要计算等式中变量的顺序，代价太大。</li>
</ol>
<p>事实上，base::reshape 有简单的写法来实现这个操作。它非常有用，而且经常被低估。你应该试试！   </p>
<h2 id="3-增强的新功能"><a href="#3-增强的新功能" class="headerlink" title="3.增强的新功能"></a>3.增强的新功能</h2><h4 id="a-增强的melt"><a href="#a-增强的melt" class="headerlink" title="a) 增强的melt"></a>a) 增强的melt</h4><p>既然我们希望简单地实现同样的操作，我们实现了一个额外的功能，这样就可以同时操作多个列。<br>－用函数melt 同时拆分多个列<br>这个办法很简单。我们给参数 measure.vars 传递一个列表，这个列表的每个元素包含需要被合并的列。</p>
<pre><code>colA = paste(&quot;dob_child&quot;, 1:3, sep = &quot;&quot;)
colB = paste(&quot;gender_child&quot;, 1:3, sep = &quot;&quot;)
DT.m2 = melt(DT, measure = list(colA, colB), value.name = c(&quot;dob&quot;, &quot;gender&quot;))
DT.m2
#     family_id age_mother variable        dob gender
#  1:         1         30        1 1998-11-26      1
#  2:         2         27        1 1996-06-22      2
#  3:         3         26        1 2002-07-11      2
#  4:         4         32        1 2004-10-10      1
#  5:         5         29        1 2000-12-05      2
#  6:         1         30        2 2000-01-29      2
#  7:         2         27        2         NA     NA
#  8:         3         26        2 2004-04-05      2
#  9:         4         32        2 2009-08-27      1
# 10:         5         29        2 2005-02-28      1
# 11:         1         30        3         NA     NA
# 12:         2         27        3         NA     NA
# 13:         3         26        3 2007-09-02      1
# 14:         4         32        3 2012-07-21      1
# 15:         5         29        3         NA     NA

str(DT.m2) ## col type is preserved
# Classes &apos;data.table&apos; and &apos;data.frame&apos;:    15 obs. of  5 variables:
#  $ family_id : int  1 2 3 4 5 1 2 3 4 5 ...
#  $ age_mother: int  30 27 26 32 29 30 27 26 32 29 ...
#  $ variable  : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 1 1 1 1 2 2 2 2 2 ...
#  $ dob       : chr  &quot;1998-11-26&quot; &quot;1996-06-22&quot; &quot;2002-07-11&quot; &quot;2004-10-10&quot; ...
#  $ gender    : int  1 2 2 1 2 2 NA 2 1 1 ...
#  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;
</code></pre><p>－函数 patterns()<br>通常，我们想整合的这些列的列名都有共通的格式。我们可以用函数patterns()指定正则表达式，让语法更简洁。上面的操作还可以这样写：</p>
<pre><code>DT.m2 = melt(DT, measure = patterns(&quot;^dob&quot;, &quot;^gender&quot;), value.name = c(&quot;dob&quot;, &quot;gender&quot;))
DT.m2
#     family_id age_mother variable        dob gender
#  1:         1         30        1 1998-11-26      1
#  2:         2         27        1 1996-06-22      2
#  3:         3         26        1 2002-07-11      2
#  4:         4         32        1 2004-10-10      1
#  5:         5         29        1 2000-12-05      2
#  6:         1         30        2 2000-01-29      2
#  7:         2         27        2         NA     NA
#  8:         3         26        2 2004-04-05      2
#  9:         4         32        2 2009-08-27      1
# 10:         5         29        2 2005-02-28      1
# 11:         1         30        3         NA     NA
# 12:         2         27        3         NA     NA
# 13:         3         26        3 2007-09-02      1
# 14:         4         32        3 2012-07-21      1
# 15:         5         29        3         NA     NA
</code></pre><p>就是这样！</p>
<ul>
<li>如果需要，我们可以去掉 variable列。</li>
<li>这个功能是用C实现的，因此效率高，节省内存，而且简洁。</li>
</ul>
<h4 id="b-增强的dcast"><a href="#b-增强的dcast" class="headerlink" title="b) 增强的dcast"></a>b) 增强的dcast</h4><p>非常好！现在我们可以同时拆分多个列了。现在我们如何将上面的 DT.m2 再恢复成原来的样子呢？<br>如果我们使用原生的函数dcast()，我们需要做两次，然后将结果合并在一起。但是这样做太麻烦，一点也不简洁和有效。<br>－同时合并多个 value.vars<br>我们可以对函数dcast()指定多个 value.var参数，这样操作就在内部进行，而且高效。</p>
<pre><code>## new &apos;cast&apos; functionality - multiple value.vars
DT.c2 = dcast(DT.m2, family_id + age_mother ~ variable, value.var = c(&quot;dob&quot;, &quot;gender&quot;))
DT.c2
#    family_id age_mother      dob_1      dob_2      dob_3 gender_1 gender_2 gender_3
# 1:         1         30 1998-11-26 2000-01-29         NA        1        2       NA
# 2:         2         27 1996-06-22         NA         NA        2       NA       NA
# 3:         3         26 2002-07-11 2004-04-05 2007-09-02        2        2        1
# 4:         4         32 2004-10-10 2009-08-27 2012-07-21        1        1        1
# 5:         5         29 2000-12-05 2005-02-28         NA        2        1       NA
</code></pre><p>说明：</p>
<ul>
<li>在结果中，原先的属性会尽量保持。</li>
<li>所有的事情都在内部高效处理。快速并且节省内存。</li>
</ul>
<p>参数fun.aggregate可以指定多个函数：</p>
<pre><code>你可以给函数dcast()的参数fun.aggregate可以指定多个函数。详细内容请执行 ?dcast 来查看示例。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/08/2016/2016-04-08-datatable5/" data-id="cj8lnyg85000dxtw82seiptww" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-04-07-human-task-switches" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/2016/2016-04-07-human-task-switches/" class="article-date">
  <time datetime="2016-04-07T06:31:55.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/2016/2016-04-07-human-task-switches/">转：任务切换有害论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>书摘，来自《软件随想录》，Joel Spolsky </p>
</blockquote>
<p>在管理一个程序团队时，第一件要学的事就是任务配置(task allocation)要正确。「任务配置」只是把事情分给大家做的夸大说法。用希伯来文的普通话来说就是「倒文件」(因为你会把文件倒在某人身上)。有些事情做得对会得到不可思议的生产力利益，决定哪些文件要倒在谁身上就是其中之一。反过来没做好的话可能就会陷入麻烦的状况，没有人能做好何任何事情而且大家都抱怨「在这里什么事都做不起来。」</p>
<p>由于这是个针对程序员的网站，我要拿个程序设计问题让你的脑袋动一动暖暖身。</p>
<p>假设你有A和B两件运算要做。每一件都需10秒的CPU时间。现在你有一颗CPU，为了简化问题，所以工作序列中没有其他东西。</p>
<p>在我们的CPU中可以选择是否用多工处理。所以你可以先做好一件再做另一件。</p>
<h5 id="循序处理"><a href="#循序处理" class="headerlink" title="循序处理"></a>循序处理</h5><p>运算A<br>1    2    3    4    5    6    7    8    9    10<br>运算B<br>11    12    13    14    15    16    17    18    19    20   </p>
<p>也可以使用多工方式。如果用多工的话可以假设这颗特别的CPU每个工作每次可以执行一秒，而且工作切换完全不花时间。</p>
<h5 id="多工处理"><a href="#多工处理" class="headerlink" title="多工处理"></a>多工处理</h5><p>运算A<br>1    3    5    7    9    11    13    15    17    19<br>运算B<br>2    4    6    8    10    12    14    16    18    20   </p>
<p>你会选哪一种方式呢？大部份人的直觉反应都认为多工比较好。不管哪一种状况，都得等20秒才能两件运算都完成。不过可以想想单就各件运算来说要多久才有结果。</p>
<p>在两种状况下，运算B(标成蓝色)都要20秒才得到结果。不过运算A的结果在多工时需要19秒。可是循序时就只要10秒就好了。</p>
<p>换句话来说在这个安排好的例子中，循序处理的每件运算的平均时间比多工处理少(15秒对19.5秒)。(事实上这例子也并不是真的那么假 - 它是源于Jared在工作上必须解决的一个真实问题。)</p>
<p>方法    运算A花的时间    运算B花的时间    平均<br>循序处理    10秒    20秒    15<br>多工处理    19秒    20秒    19.5   </p>
<p>我刚刚说过「工作切换完全不花时间」。其实在真的CPU中工作切换是需要一点点时间的，基本上要足够储存CPU暂存器的状态并载入其他工作的CPU暂存器。实际上这短到几乎可以忽略。不过为了让生活更多乐趣，让我们假设工作切换需要半秒。现在情况变得更糟了：</p>
<p>方法    运算A花的时间    运算B花的时间    平均<br>循序处理    10秒    20秒 + 1次工作切换 = 20.5秒    15.25<br>多工处理    19秒 + 18次工作切换 = 28秒    20秒 + 19次工作切换 = 29.5秒    28.75   </p>
<p>现在呢，虽然我知道这有点蠢，不过就算为了让我高兴一下，想想如果工作切换需要一分钟拿如何？</p>
<p>方法    运算A花的时间    运算B花的时间    平均<br>循序处理    10秒    20秒 + 1次工作切换 = 80秒    45秒<br>多工处理    19秒 + 18次工作切换 = 1099秒    20秒 + 19次工作切换 = 1160秒    几近19分钟!!   </p>
<p>工作切换用的时间愈长，多工处理的代价愈大。</p>
<p>这件事本身不怎么新奇，不是吗？不久大概就会有些白痴气愤地写信指控我「反对」多工处理了。他们会质问我：「你真的想要回到那种得先结束WordPerfect才能执行Lotus 1-2-3的DOS时代吗？」</p>
<p>不过那并不是我的意思。我只是想要你同意，在这类例子中：</p>
<ul>
<li>循序处理会让结果平均上比较快得到，而且</li>
<li>工作切换需要愈久，多工处理所付的代价就愈大。</li>
</ul>
<p>够了，别管CPU了，来管管人吧，这有趣多了。这里的重点在于管理「程序员」时，工作切换会需要很长很长的时间。因为程序设计这种工作必须同时在脑袋里记很多东西。另外记住的东西愈多，写程序时生产力愈高。用全速写程序的程序员脑里随时都会记住无数的事情：变量名称，数据结构，重要的API，写过常要用到的辅助函数名称，甚至存放源代码的次目录名称，一切东西都要记住。如果你把程序员送到克利特岛去度假三星期，他所有东西通通都会忘掉。人脑似乎会把东西移出短期RAM，改存到永远都读不回来的备份磁带上。</p>
<p>要多久呢？嗯，我的软件公司最近放下手头上在做的事(开发一套代号CityDesk的软件产品)，花了三星期去帮助某个客户处理一个紧急状况。当我们回到办公室时，感觉好像要另外三星期才能回复全速制作CityDesk。</p>
<p>就个人层次来说，你曾经注意过某件事吗？叫某人做一个工作可以做得很好，可是如果给他两个工作，他会把其中一个做好却忽略另一个，不然就是两件工作都做得很慢，慢到你觉得懒鬼都比他勤劳。这是因为程序设计的工作就是需要很长的切换时间。就我自己来说，当我需要同时完成两个程序设计项目时，切换时间大概要六个小时。以一天八小时来看，等于说多工处理把我的生产力降到每天只剩二小时。真令人沮丧啊。</p>
<p>同样的道理，如果你给某人两件工作，应该要感谢他们只做一件工作而放弃另一件，因为这样能做好更多的事，而且平均上也能更快完成工作。事实上这一切的重点就是绝对不要让人同时做一件以上的事。请确定你有明白它的意思。好的经理人会认为自己的责任是消除障碍，好让大家都能专注在一件事情并把它真的完成。遇到紧急状况时，请先想想能不能自己处理掉，真的不行再丢给深陷在项目中的程序员吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/2016/2016-04-07-human-task-switches/" data-id="cj8lnyg7z000bxtw89wjqji8b" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-04-02-datatable4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/01/2016/2016-04-02-datatable4/" class="article-date">
  <time datetime="2016-04-01T15:38:11.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/新知/">新知</a>►<a class="article-category-link" href="/categories/新知/data-table教程/">data.table教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/01/2016/2016-04-02-datatable4/">data.table 教程4－二级索引和自动索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目录：   </p>
<ol>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-13-datatable1/" target="_blank" rel="external">data.table 介绍</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-21-datatable2/" target="_blank" rel="external">语义引用</a>      </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-03-22-datatable3/" target="_blank" rel="external">主键、基于二分法搜索的subset</a>    </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-02-datatable4/" target="_blank" rel="external">二次索引和自动索引</a>   </li>
<li><a href="http://youngspring1.github.io/post/2016/2016-04-08-datatable5/" target="_blank" rel="external">数据拆分和合并</a>   </li>
</ol>
<p>原文地址：<br><a href="https://github.com/Rdatatable/data.table/wiki/Getting-started" target="_blank" rel="external">data.table/wiki/Getting-started</a></p>
<hr>
<p>感谢<a href="http://weibo.com/u/2120911240" target="_blank" rel="external">G_天星</a>的提醒，貌似现在版本的data.table中还没有setindex()函数，所以可能应该使用set2key()函数。或者通过代码安装data.table试试。</p>
<hr>
<h1 id="二级索引和自动索引"><a href="#二级索引和自动索引" class="headerlink" title="二级索引和自动索引"></a>二级索引和自动索引</h1><p>本教程假定读者已经熟悉data.table的[i, j, by]语法、懂得如何基于二分法的选取了。如果你对这些不熟悉，请学习上面三讲 <a href="http://youngspring1.github.io/post/2016-03-13-datatable1/" target="_blank" rel="external">data.table 介绍</a> 、 <a href="http://youngspring1.github.io/post/2016-03-21-datatable2/" target="_blank" rel="external">语义引用</a>和<a href="http://youngspring1.github.io/post/2016-03-22-datatable3/" target="_blank" rel="external">主键、基于快速二分法搜索的subset</a>。 </p>
<hr>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>我们继续使用已经保存到本地的航班信息flights。</p>
<pre><code>flights &lt;- fread(&quot;flights14.csv&quot;)
head(flights)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
# 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18
dim(flights)
# [1] 253316     11
</code></pre><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这一讲，我们会：   </p>
<ul>
<li>讨论二级索引。  </li>
<li>再次演示快速subset，但这次我们使用新的参数on，它能自动设置二级索引。</li>
<li>最后进一步的，来看一下自动索引，它也能自动设置索引，但是它是基于R的原生语法来做subset的。</li>
</ul>
<h2 id="1-二级索引"><a href="#1-二级索引" class="headerlink" title="1.二级索引"></a>1.二级索引</h2><h4 id="a-什么是二级索引"><a href="#a-什么是二级索引" class="headerlink" title="a) 什么是二级索引"></a>a) 什么是二级索引</h4><p>二级索引和data.table的主键类似，但有以下两点不同：</p>
<ul>
<li>它不会再内存里将整个data.table重新排序。它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。</li>
<li>一个data.table可以有多个二级索引，这是我们下面要演示的。</li>
</ul>
<h4 id="b-设置和获取二级索引"><a href="#b-设置和获取二级索引" class="headerlink" title="b) 设置和获取二级索引"></a>b) 设置和获取二级索引</h4><p>－如何将origin列设置为该data.table的二级索引</p>
<pre><code>setindex(flights, origin)
head(flights)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
# 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18

## alternatively we can provide character vectors to the function &apos;setindexv()&apos;
# setindexv(flights, &quot;origin&quot;) # useful to program with

# &apos;index&apos; attribute added
names(attributes(flights))
# [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;
# [5] &quot;index&quot;
</code></pre><p>说明：   </p>
<ul>
<li>函数setindex 和 setindexv()可以对data.table添加一个二级索引。</li>
<li>注意flights实际上没有按照origin列的升序重新排列。还记得吗？setkey()会重新排序！</li>
<li>setindex(flights, NULL)会删除所有的二级索引。</li>
</ul>
<p>－如何取得flights的二级索引</p>
<pre><code>indices(flights)
# [1] &quot;origin&quot;

setindex(flights, origin, dest)
indices(flights)
# [1] &quot;origin&quot;       &quot;origin__dest&quot;
</code></pre><p>说明：   </p>
<ul>
<li>函数indices()返回一个data.table所有的二级索引。如果该data.table没有二级索引，那么返回NULL。</li>
<li>注意我们对 origin列,dest列创建了另一个二级索引的时候，我们没有丢掉之前创建的第一个二级索引。也就是说，我们可以创建多个二级索引。</li>
</ul>
<h4 id="c-为什么使用二级索引"><a href="#c-为什么使用二级索引" class="headerlink" title="c) 为什么使用二级索引"></a>c) 为什么使用二级索引</h4><p>－对一个data.table重新排序成本太高<br>考虑一下这种情况，当你想用主键origin列来subset所有“JFK”的时候，我们得这么做：</p>
<pre><code>## not run
setkey(flights, origin)
flights[&quot;JFK&quot;] # or flights[.(&quot;JFK&quot;)]
</code></pre><p>说明：</p>
<pre><code>setkey()需要：
a.计算得出origin列的排序向量，并且
b.基于刚刚的排序向量，对整个data.table重新排序
</code></pre><p>排序并不是最花时间的，因为data.table使用对整型、字符型、数值型的向量进行radix排序。然而重新排序却很花时间。<br>除非我们需要对某一列重复地进行subset，否则二分法快速subset的高效可能被重新排序抵消。   </p>
<p>－为添加／更新列而对整个data.table重新排序并不理想<br>－最多只能有一个主键<br>现在我们如果想对dest列是“LAX”的行，重复地进行某个特定的操作，那么我们必须再调用函数setkey() 设置一次主键。   </p>
<pre><code>## not run
setkey(flights, dest)
flights[&quot;LAX&quot;]
</code></pre><p>这样，flights又再次按dest列重新排序了。其实我们真正想做的是，快速地subset同时又不必重新排序。<br>这时候，二级索引就派上用场了！   </p>
<p>－二级索引可以被重用<br>既然一个data.table中可以有多个二级索引，并且创建一个二级索引就和将一个排序向量保存为属性一样简单，那么创建二级索引后，我们可以省下重新排序的时间。<br>－参数on使得语法更简洁，并且能自动创建并重用二级索引<br>我们下面一节会说明参数on的几个优点：   </p>
<p>参数on</p>
<ul>
<li>通过创建索引进行subset。每次都能节省setindex()的时间。</li>
<li>通过检查属性，可以简单地重用已经存在的二级索引。</li>
<li>语法简单。<br>注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。</li>
</ul>
<h2 id="2-使用参数on和索引进行快速subset"><a href="#2-使用参数on和索引进行快速subset" class="headerlink" title="2.使用参数on和索引进行快速subset"></a>2.使用参数on和索引进行快速subset</h2><h4 id="a-参数i里的subset"><a href="#a-参数i里的subset" class="headerlink" title="a) 参数i里的subset"></a>a) 参数i里的subset</h4><p>－subset所有origin是“JFK”的行</p>
<pre><code>flights[&quot;JFK&quot;, on = &quot;origin&quot;]
#        year month day dep_delay arr_delay carrier origin dest air_time distance hour
#     1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
#     2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
#     3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
#     4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
#     5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
#    ---
# 81479: 2014    10  31        -4       -21      UA    JFK  SFO      337     2586   17
# 81480: 2014    10  31        -2       -37      UA    JFK  SFO      344     2586   18
# 81481: 2014    10  31         0       -33      UA    JFK  LAX      320     2475   17
# 81482: 2014    10  31        -6       -38      UA    JFK  SFO      343     2586    9
# 81483: 2014    10  31        -6       -38      UA    JFK  LAX      323     2475   11

## alternatively
# flights[.(&quot;JFK&quot;), on = &quot;origin&quot;] (or) 
# flights[list(&quot;JFK&quot;), on = &quot;origin&quot;]
</code></pre><p>说明：</p>
<ul>
<li>这段语句执行的subset也是通过创建二级索引，基于快速二分法搜索的。但记住，它不会把这个二级索引自动创建为data.table的一个属性。当然后面我们也会教你如何将它设置为一个属性。   </li>
<li>如果我们已经添加了一个二级索引了，那么参数on就可以直接使用这个二级索引，而不是再对整个航班信息flights进行计算。   </li>
</ul>
<p>我们来看下面 verbose = TRUE 的用法：</p>
<pre><code>setindex(flights, origin)
flights[&quot;JFK&quot;, on = &quot;origin&quot;, verbose = TRUE][1:5]
# names(on) = NULL. Assigning &apos;on&apos; to names(on)&apos; as well.
# Looking for existing (secondary) index... found. Reusing index.
# Starting bmerge ...done in 0 secs
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
</code></pre><p>－如何对origin列和dest列进行subset<br>举个例子，如果我们想选取所有从“JFK”起飞到达“LAX”的所有航班：</p>
<pre><code>flights[.(&quot;JFK&quot;, &quot;LAX&quot;), on = c(&quot;origin&quot;, &quot;dest&quot;)][1:5]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
# 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
# 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
# 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21
</code></pre><p>说明：</p>
<ul>
<li>在参数i里面指定取值，在参数on里面指定列名。参数on必须是一个字符型的向量。   </li>
<li>因为计算索引非常快，所以我们不需要使用setindex()。除非你需要对某一列重复地进行subset操作。   </li>
</ul>
<h4 id="b-参数j里的select"><a href="#b-参数j里的select" class="headerlink" title="b) 参数j里的select"></a>b) 参数j里的select</h4><p>下面我们将要讨论的所有操作，跟我们在上一讲里面学习的类似。只是我们现在使用参数on。<br>－返回满足条件 origin = “LGA” and dest = “TPA”的 arr_delay列的值</p>
<pre><code>flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)]
#       arr_delay
#    1:         1
#    2:        14
#    3:       -17
#    4:        -4
#    5:       -12
#   ---          
# 1848:        39
# 1849:       -24
# 1850:       -12
# 1851:        21
# 1852:       -11
</code></pre><h4 id="c-Chaining"><a href="#c-Chaining" class="headerlink" title="c) Chaining"></a>c) Chaining</h4><p>－在上面的基础上，使用chaining来将结果降序排列</p>
<pre><code>flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)][order(-arr_delay)]
#       arr_delay
#    1:       486
#    2:       380
#    3:       351
#    4:       318
#    5:       300
#   ---          
# 1848:       -40
# 1849:       -43
# 1850:       -46
# 1851:       -48
# 1852:       -49
</code></pre><h4 id="d-参数j里的计算"><a href="#d-参数j里的计算" class="headerlink" title="d) 参数j里的计算"></a>d) 参数j里的计算</h4><p>－找出满足条件 origin = “LGA” and dest = “TPA”的 arr_delay列的最大值（航班到达的最长延误时间）</p>
<pre><code>flights[.(&quot;LGA&quot;, &quot;TPA&quot;), max(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)]
# [1] 486
</code></pre><h4 id="e-参数j里使用操作符”-”进行sub-assign"><a href="#e-参数j里使用操作符”-”进行sub-assign" class="headerlink" title="e) 参数j里使用操作符”:=”进行sub-assign"></a>e) 参数j里使用操作符”:=”进行sub-assign</h4><p>在上一讲中，我们学习过了类似的功能。同样地，现在我们看看如何找到在flights里面，hours列所有可能的取值：   </p>
<pre><code># get all &apos;hours&apos; in flights
flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
</code></pre><p>可以看到，一共有25种不同的取值。但是0点和24点其实是同样的。下面我们把24全部替换成0，但是这次我们使用参数on。   </p>
<pre><code>flights[.(24L), hour := 0L, on = &quot;hour&quot;]
</code></pre><p>现在我们再来看看24是不是都被替换成0了：   </p>
<pre><code>flights[, sort(unique(hour))]
#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
</code></pre><p>说明：</p>
<ul>
<li>这真是二级索引的一大优点。以前，只是为了更新一些行的hour列的取值，我们不得不调用函数setkey()将hour列设置为主键，这必须对整个data.table进行重新排序。但是现在，用参数on，原数据的顺序并没有改变，操作反而更快了！而代码还是如此简洁。   </li>
</ul>
<h4 id="f-通过参数by聚合"><a href="#f-通过参数by聚合" class="headerlink" title="f) 通过参数by聚合"></a>f) 通过参数by聚合</h4><p>－找到每月从“JFK”起飞的航班起飞的最长延误时间，并按照月份排序</p>
<pre><code>ans &lt;- flights[&quot;JFK&quot;, max(dep_delay), keyby = month, on = &quot;origin&quot;]
head(ans)
#    month   V1
# 1:     1  881
# 2:     2 1014
# 3:     3  920
# 4:     4 1241
# 5:     5  853
# 6:     6  798
</code></pre><p>说明：</p>
<ul>
<li>如果我们不使用二级索引，也就是不在参数on里面指定，那么我们就必须把origin设置为主键。   </li>
</ul>
<h4 id="g-参数mult"><a href="#g-参数mult" class="headerlink" title="g) 参数mult"></a>g) 参数mult</h4><p>参数mult和上一讲一样。它的默认值是“all”。我们可以选择是第一条还是最后一条符合条件的行被返回。<br>－subset满足条件dest ＝ “BOS” 和 “DAY”的第一行   </p>
<pre><code>flights[c(&quot;BOS&quot;, &quot;DAY&quot;), on = &quot;dest&quot;, mult = &quot;first&quot;]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1         3         1      AA    JFK  BOS       39      187   12
# 2: 2014     1   1        25        35      EV    EWR  DAY      102      533   17
</code></pre><p>－subset满足条件 origin ＝ “LGA” 或者 “JFK” 或者 “EWR”，并且 dest ＝ “XNA” 的最后一行   </p>
<pre><code>flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), on = c(&quot;origin&quot;, &quot;dest&quot;), mult = &quot;last&quot;]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6
# 2:   NA    NA  NA        NA        NA      NA    JFK  XNA       NA       NA   NA
# 3: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6
</code></pre><h4 id="h-参数nomatch"><a href="#h-参数nomatch" class="headerlink" title="h) 参数nomatch"></a>h) 参数nomatch</h4><p>如果查询语句没有找到任何匹配的数据，通过指定参数nomatch，我们可以选择是返回 NA，还是忽略。<br>－在上面这个列子中，忽略没有实际意义的数据   </p>
<pre><code>flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), mult = &quot;last&quot;, on = c(&quot;origin&quot;, &quot;dest&quot;), nomatch = 0L]
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6
# 2: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6
</code></pre><p>说明：</p>
<ul>
<li>没有航班从“JFK”起飞到达“XNA”，所以结果里面，这一行被忽略了。   </li>
</ul>
<h2 id="3-自动索引"><a href="#3-自动索引" class="headerlink" title="3.自动索引"></a>3.自动索引</h2><p>回顾一下，我们先学习如何通过主键使用快速二分法搜索进行subset。接着，我们学习了使用二级索引，它带来更好的效果，而且语法也更简洁。<br>等等，有没有更好的方法？有！优化R的原生语法，使用内置的索引。这样我们毋需使用新的语法，就能得到同样的效果。<br>这就是自动索引。<br>目前，它只支持操作符 == 和 %in% 。而且只对一列起作用。某一列会被自动创建为索引，并且作为data.table的属性保存起来。这跟参数on不同，参数on会每次创建一个临时索引，所以才会被叫做“二级索引”。   </p>
<p>让我们创建一个极大的data.table来凸显它的优势。  </p>
<pre><code>set.seed(1L)
dt = data.table(x = sample(1e5L, 1e7L, TRUE), y = runif(100L))
print(object.size(dt), units = &quot;Mb&quot;)
# 114.4 Mb
</code></pre><p>当我们第一次对某一列使用 == 或者 %in% 的时候，会自动创建一个二级索引，它会被用来进行subset。</p>
<pre><code># have a look at all the attribute names
names(attributes(dt))
# [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;

## run thefirst time
(t1 &lt;- system.time(ans &lt;- dt[x == 989L]))
#    user  system elapsed 
#   0.235   0.013   0.249
head(ans)
#      x         y
# 1: 989 0.5372007
# 2: 989 0.5642786
# 3: 989 0.7151100
# 4: 989 0.3920405
# 5: 989 0.9547465
# 6: 989 0.2914710

## secondary index is created
names(attributes(dt))
# [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;
# [5] &quot;index&quot;

indices(dt)
# [1] &quot;x&quot;
</code></pre><p>第一次subset的时候，就是创建索引的时候。因为创建二级索引只会引入一个排序向量，在很多情况下，这种操作符的方式会比扫描向量快得多。所以，从第二次subset开始，自动索引的优势就非常明显了：</p>
<pre><code>## successive subsets
(t2 &lt;- system.time(dt[x == 989L]))
#    user  system elapsed 
#   0.001   0.000   0.001
system.time(dt[x %in% 1989:2012])
#    user  system elapsed 
#   0.001   0.000   0.001
</code></pre><p>说明：</p>
<ul>
<li>第一次subset花了0.228秒，但是第二次只花了0.001秒！   </li>
<li>可以通过设置全局参数关闭自动索引：options(datatable.auto.index = FALSE)。   </li>
</ul>
<p>我们正在将二分法搜索扩展到其它的操作符，比如 &lt;, &lt;= 和 &gt;=。完成之后，就能直接用在其他操作符上了。<br>在将来，我们计划将自动索引扩展到参数中的其它列。   </p>
<p>在下一讲“结合和滚动结合”中，我们会学习使用主键和二级索引进行快速subset。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/01/2016/2016-04-02-datatable4/" data-id="cj8lnyg7x0009xtw87ra9l9ud" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016/2016-03-30-write-fd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/30/2016/2016-03-30-write-fd/" class="article-date">
  <time datetime="2016-03-30T05:19:46.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/2016/2016-03-30-write-fd/">为什么程序员要写功能设计书</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>续上篇，还是阅读了《软件随想录》之后，希望把以前的思考再总结一下。   </p>
<hr>
<h2 id="1-什么是功能设计书"><a href="#1-什么是功能设计书" class="headerlink" title="1.什么是功能设计书"></a>1.什么是功能设计书</h2><pre><code>功能设计书
  从用户的角度，完整描述了程序的行为。它只介绍了程序的功能、交互方式，并不涉及具体的实现方式。   

技术设计书
  指引程序员，如何实现功能设计书所描述的功能。它涉及数据结构、数据库、程序语言、算法等等内部的实现细节。   
</code></pre><p>从头开始设计一个程序时，最重要的，是完成对用户交互的设计：用户需要哪些功能；这些功能具体需要哪些页面来实现；页面如何操作。<br>功能设计书的写作者需要将整个软件的所有可能的使用场景、流程，在自己的脑海中想象出来，并展现在功能设计书当中。   </p>
<h2 id="2-为什么要写功能设计书"><a href="#2-为什么要写功能设计书" class="headerlink" title="2.为什么要写功能设计书"></a>2.为什么要写功能设计书</h2><p>有好多同事觉得写设计书没有必要，浪费开发的时间，而且对个人能力没有提升。<br>我无法想象他们是如何得到这些结论的。可能我在学生时代也是这么想的，看到一个任务就马上写代码，但我早就不这样做了。</p>
<h4 id="2-1-设计"><a href="#2-1-设计" class="headerlink" title="2.1 设计"></a>2.1 设计</h4><p>功能设计书最重要作用，就是对程序所有的功能进行设计。通过写文档描述所有页面交互的细节，你会被迫对程序做真正的设计。<br>在程序的使用中，有可能遇到什么问题，应该如何处理，你在设计阶段就应该想清楚。在写作中，那些可能出问题的地方，大部分都能暴露出来；而如果不写设计书，当你写了一些代码之后，才发现这些问题，付出的代价会更大。<br>所以设计能够大幅度缩短整个项目的开发周期。   </p>
<p>更重要的，这对你个人的思维能力和表达能力都很有提升。<br>看上去，设计的成果是一篇文档，但为了写作这篇文档，你在脑海中进行的一系列思维活动，才是你最大的收获。</p>
<h4 id="2-2-沟通"><a href="#2-2-沟通" class="headerlink" title="2.2 沟通"></a>2.2 沟通</h4><p>有没有回忆起，用户／开发人员／测试人员一次次的跟你确认功能设计的情景？他们东一句西一句地跑过来问你各种愚蠢的问题，你的工作时间被消磨殆尽。<br>通过功能设计书，你只需要跟别人沟通一次；其他人员只要去阅读功能设计书，就能知道你能给他们的所有信息。<br>如果没有功能设计书，你只能一遍一遍地讲给他们听。<br>更可怕的是，如果没有功能设计书，测试人员会根据程序的输入输出来测试程序，或者根据开发人员的实现细节来测试程序，而不是基于设计来设计程序。   </p>
<h4 id="2-3-计划"><a href="#2-3-计划" class="headerlink" title="2.3 计划"></a>2.3 计划</h4><p>如果没有功能设计书把所有的功能点／页面罗列出来，如何安排计划呢。</p>
<h2 id="2-谁来读功能设计书"><a href="#2-谁来读功能设计书" class="headerlink" title="2.谁来读功能设计书"></a>2.谁来读功能设计书</h2><pre><code>客户
  这里的客户，是那些付钱给你开发程序的人。
  友情提醒你一下，要把他们想象成一毛不拔的铁公鸡，妄图只花5块钱买一架航空母舰。
  写作功能设计书的时候，需要一遍又一遍的跟他们确认，跟他们的想象和需求是否一致。这里的功能设计书，就是必须的“立字据”。基本完成之后，再修改是要加钱的哦。
用户
  这里的用户，是那些使用程序的人。
  友情提醒你一下，要把他们想象成又笨又懒的人，他们什么都不会，什么都不想做。
  但你的功能设计书，必须要把他们教会使用这个程序。
技术设计书的作者
  技术设计书的作者，需要根据功能设计书，考虑如何实现程序。
开发人员
  开发人员，主要按照技术设计书来实现程序，但是也会参考功能设计书，确认功能是否都实现了，页面流程是否一致。
测试人员
  测试人员，需要按照功能设计书来写测试案例，并最终实施测试任务。
</code></pre><h2 id="3-谁来写功能设计书"><a href="#3-谁来写功能设计书" class="headerlink" title="3.谁来写功能设计书"></a>3.谁来写功能设计书</h2><p>不同的公司，会有不同的职位和称呼，而且写作功能设计书的人，又不是专职写作功能设计书的。<br>所以这里，我并不会将什么人来写，而是简单说下，写作功能设计书的人，需要哪些素质。</p>
<h4 id="3-1-技术能力"><a href="#3-1-技术能力" class="headerlink" title="3.1 技术能力"></a>3.1 技术能力</h4><p>虽然功能设计书本身并不涉及具体的实现方式，但是，作者必须明白，功能点都是在成本范围内能够实现。这就要求作者必须要有技术功底。<br>这也是为什么，本文的标题是“为什么程序员要写功能设计书”，有过开发背景的人，才会具备技术功底。其他人员，很可惜，我觉得不具备写作功能设计书的能力。   </p>
<h4 id="3-2-思维能力"><a href="#3-2-思维能力" class="headerlink" title="3.2 思维能力"></a>3.2 思维能力</h4><p>将脑海中的设计，通过确切的图片和简要的语言，展现在文档中。我认为这不是写作能力，而是思维能力。</p>
<h4 id="3-3-沟通能力"><a href="#3-3-沟通能力" class="headerlink" title="3.3 沟通能力"></a>3.3 沟通能力</h4><p>功能设计书不是独自写完就可以的。而是要跟其他所有读者沟通达成一致后，才能最终定稿。   </p>
<h2 id="4-如何写功能设计书"><a href="#4-如何写功能设计书" class="headerlink" title="4.如何写功能设计书"></a>4.如何写功能设计书</h2><h4 id="4-1-应当包含哪些要素"><a href="#4-1-应当包含哪些要素" class="headerlink" title="4.1 应当包含哪些要素"></a>4.1 应当包含哪些要素</h4><pre><code>概述
  该程序的主要功能。
使用场景
  在什么情况下，可以使用该程序。
流程图
  程序各个页面的关系，也是整个服务的全貌。
每个页面的功能说明
  所有页面的详细功能。
细节！细节！细节！
  重要的事情说三遍。页面上所有可能出现的细节都要考虑到，所有可能影响页面的因素都要考虑到。在这些情况下，程序如何反应，写下来。
待解决的问题
  文档不可能在第一版就达到完善的状态，这是你要把还不清楚的地方写下来。
多角度的注解
  主要是从开发人员或者测试人员的角度，需要注意的细节。
修改履历
  所有的读者，都会根据修改履历，大概了解每次修改的功能点和位置。
</code></pre><h4 id="4-2-写作原则"><a href="#4-2-写作原则" class="headerlink" title="4.2 写作原则"></a>4.2 写作原则</h4><pre><code>简单
  能用图片的，尽量用图片而不是语言。能少说的，就不多说。
用户角度
  从用户的角度思考问题，想想用户需要知道什么信息。
评审
  自己阅读，甚至大声朗读几遍。拿给所有必需的读者看。再修改。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/30/2016/2016-03-30-write-fd/" data-id="cj8lnyg7w0007xtw8gcn77alv" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/数据分析笔记/">数据分析笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据分析笔记/新知/">新知</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/新知/">新知</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/新知/data-table教程/">data.table教程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习的数学基础/">机器学习的数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/07/02/2017/2017-07-02-food/">迷上做饭视频</a>
          </li>
        
          <li>
            <a href="/2017/06/25/2017/2017-06-25-jizhi/">集智网文章索引</a>
          </li>
        
          <li>
            <a href="/2017/06/24/2017/2017-06-24-DLmaterials/">(发福利)深度学习资料</a>
          </li>
        
          <li>
            <a href="/2017/06/24/2017/2017-06-24-fromdaily/">算法来自日常工作</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>